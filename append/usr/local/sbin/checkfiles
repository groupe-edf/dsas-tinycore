#! /bin/sh
#    DSAS - Tinycore
#    Copyright (C) 2021-2022  Electricite de France
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Shellcheck configuration to test for POSIX shell plus the Busybox/ASH extensions I use
# shellcheck shell=sh
# Allow process subsitution with "<()"
# shellcheck disable=SC3001
# Allow "[["
# shellcheck disable=SC3010
# Allow "-ef" to test if same file (ie hardlink)
# shellcheck disable=SC3013
# Allow local variables
# shellcheck disable=SC3043
# Allow "read -d"
# shellcheck disable=SC3045
# Allow string indexing like "${1:3}"
# shellcheck disable=SC3057

if [ -f "$(dirname "$0")/dsas_common.sh" ]; then
  # shellcheck source=append/usr/local/sbin/dsas_common.sh
  . "$(dirname "$0")/dsas_common.sh"
else
  1>&2 echo "Common functions not found !!"
  exit 1
fi
getcert=$(dirname "$0")/getcertificate

# Default options
logfile="$LOG/dsas_verif.log"
UMASK=640
export UMASK
clamav=0
antivirus=0
grp=share
logstdout=0
verbose=0
dryrun=0

help() {
  echo "Usage: $(basename "$0")  [Options] ID [ID...]"
  echo "Verify files given by the task ID."
  echo "     -v|--verbose    Log all files verified"
  echo "     -q|--quiet      Log only files failing to verify"
  echo "     -n|--dryrun     Perform no actions"
  echo "     -c|--clamav     Check ClamAv signature files"
  echo "     -s|--stdout     Send logs to stdout"
  echo "     -l|--log        Send the logs to a file"
  echo "     -o <FILE>       Log to <FILE>, default $logfile"
  echo "     --out=<FILE>    Log to <FILE>"
  echo "     -h|--help       Print this help"
}

cleanup_and_exit() {
  status=$1
  shift
  while [ "$#" -gt 0 ]; do
    /bin/rm -fr "$1"
    shift
  done
  exit "$status"
}

msg() {
  if [ "$logstdout" -eq 1 ]; then
    printf "%-3s %-15s %-32s %s %s\n" "$1" "$2" "$3" "$4" "$5"
  elif [ -n "$logfile" ]; then
    [ "$verbose" -ne 0 ] &&  printf "%-3s %-15s %-32s %s %s\n" "$1" "$2" "$3" "$4" "$5"
    printf "%-3s %-15s %-32s %s %s\n" "$1" "$2" "$3" "$4" "$5" >> "$logfile"
  fi
}

msgline() {
  local file status md5 _file d
  file=$1
  status=$2
  md5=$(md5sum "$file" | sed -e "s:  $file$::g")
  _file=$(echo "$file" | sed -e "s:^${DSAS_HAUT}/::g")
  d=$(date --utc '+%Y%m%d%H%M%S')
  case $status in
    0)   msg "  "  "Ok"             "$md5"  "$d" "$_file" ;;
    -1)  msg "XX"  "Unknown type"   "$md5"  "$d" "$_file" ;;
    1)   msg "**"  "Bad Sig"        "$md5"  "$d" "$_file" ;;
    2)   msg "--"  "Checksum fail"  "$md5"  "$d" "$_file" ;;
    3)   msg "**"  "Bad Interm Sig" "$md5"  "$d" "$_file" ;;
    4)   msg "**"  "Fail virus chk" "$md5"  "$d" "$_file" ;;
    5)   msg "**"  "Bad RPM Sig"    "$md5"  "$d" "$_file" ;;
    255) msg "**"  "Not signed"     "$md5"  "$d" "$_file" ;;
    *)   msg "XX"  "Unknown status" "$md5"  "$d" "$_file" ;;
  esac
}

myecho(){
  [ $verbose -ne 0 ] && echo "$@"
  # If not verbose the status will be 1. explicitly return 0
  return 0
}

rm() {
  if [ "$dryrun" = "0" ]; then
    #FIXME is there a better way of handling spaces in the args ?
    while [ "$#" -gt 0 ]; do
      /bin/rm -fr "$1"
      shift
    done
  else
    echo "[DryRun] rm $*"
  fi
}

task_id_to_idx(){
  local _task_id
  local i=1
  while :; do
    _task_id=$(xmllint --xpath "string(dsas/tasks/task[$i]/id)" "$CONF")
    [ -z "$_task_id" ] && return 1;
    [ "$1" = "$_task_id" ] && echo $i && return 
    i=$((i + 1))
  done
}

# Usage : check_checksum <file> <chksum> <type>
check_checksum() {
  local chk

  case $3 in
    sha512) chk=$(sha512sum "$1" | sed -e "s:  $1$::g") ;;
    sha256) chk=$(sha256sum "$1" | sed -e "s:  $1$::g") ;;
    sha) chk=$(sha1sum "$1" | sed -e "s:  $1$::g") ;;
    md5) chk=$(md5sum "$1" | sed -e "s:  $1$::g") ;;
    *) return 0 ;;
  esac
  [ "$chk" != "$2" ] && return 0
  return 1
}

ln() {
  if [ "$dryrun" = "0" ]; then
    [ -d "$(dirname "$2")" ] || mkdir "$(dirname "$2")"
    # This script is not running as root so can't change the owner. We
    # first have to copy the file.
    # FIXME : Hardcode path to gnu version of cp for the "--preserve" flag
    /usr/local/bin/cp --preserve=timestamp "$1" "$1.tmp.$$"
    /bin/mv -f "$1.tmp.$$" "$1"
    chmod 0640 "$1"
    chgrp "$grp" "$1"
    /bin/ln -f "$1" "$2" 
  else
    [ -d "$(dirname "$2")" ] || echo "[DryRun] mkdir -m 770 -p $(dirname "$2")"
    echo "[DryRun] ln $*"
  fi
}

mkdir() {
  # A command like "mkdir -m UMASK -p $dir" doesn't apply the
  # umask to all directories. This function just enforces the
  # desired permissions and ownerships. Passed only directories
  local _d _d2

  while [ "$#" -gt 0 ]; do
    _d=$1
    _d2=$(dirname "$_d")
    while [ ! -d "$_d2" ]; do
      _d="$_d2"
      _d2=$(dirname "$_d2")
    done
    /bin/mkdir -p "$1"
    chgrp -R "$grp" "$_d"
    chmod -R 770 "$_d"  
    shift
  done
}

verifauthenticode(){
  local _file hash hashes sigdir id tempdir file
  id=$1
  tempdir="$2"
  file="$3"
  _time=$(stat -c%Y "$file")  # Verification date same as file createion date

  if [ -f "$tempdir/cert.0" ]; then
    osslsigncode verify -CAfile "$tempdir/cert.0" -time "$_time" "$file" > /dev/null 2>&1 || \
        osslsigncode verify -CAfile "$tempdir/cert.0" -TSA-CAfile "$tempdir/cert.0" -time "$_time" "$file" > /dev/null 2>&1 || \
        return 1
  else
    osslsigncode verify "$file" > /dev/null 2>&1 || return 1
  fi

  if [ -f "$tempdir/cert.1" ]; then
    # Don't use the -require-leaf-hash of osslsigncode as it only checks the leaves and not the
    # intermediate certificates since version 2.2. Extract all of the certificates from the file 
    # and check them against the hash. If osslsigncode goes back to the behavior of version 2.1 
    # this block can be replaced with one line with the -require-leaf-hash option
    sigdir=$(mktemp -d)
    osslsigncode extract-signature -pem -out "$sigdir/sig.pkcs7" -in "$file" > /dev/null 2>&1

    # There can be multiple signatures in the PKCS7 file. openssl will only treat the 
    # first one normally. Find the offsets in the file for each signature block, and treat
    # each seperately
    offsets="0 $(openssl asn1parse -inform pem -in "$sigdir/sig.pkcs7" 2> /dev/null | grep -B 1 pkcs7-signedData | \
        grep -x -A 1 '\-\-' | grep ':' | cut -d: -f1)"

    hashes=""
    for offset in $offsets; do
      openssl pkcs7 -inform pem -in "$sigdir/sig.pkcs7" -outform der | dd bs=1 skip="$offset" status=none | \
          openssl pkcs7 -inform der -print_certs 2> /dev/null | \
          awk -v tmp="$sigdir" 'split_after==1{n++;split_after=0} /-----END CERTIFICATE-----/ {split_after=1}{if (length($0) > 0) print > tmp "/sig" n ".pem"}'

      while IFS= read -r -d '' _file; do
        hashes="$hashes $(openssl x509 -in "$_file" -noout -fingerprint -sha256 -inform pem 2>&1 | \
            cut -d= -f2 | sed -e 's/://g' | tr '[:upper:]' '[:lower:]')"
      done < <(find "$sigdir" -name "sig*.pem" -print0)
      /bin/rm -f "$sigdir/sig*.pem"
    done
    /bin/rm -fr "$sigdir"

    for _file in "$tempdir"/*; do
      [ "$(basename "$_file")" = "cert.0" ] && continue
      hash="$(openssl x509 -in "$_file" -noout -fingerprint -sha256 -inform pem 2>&1 | \
          cut -d= -f2 | sed -e 's/://g' | tr '[:upper:]' '[:lower:]')"
      [[ "$hashes" =~ $hash ]] || return 3
    done
  fi

  return 0
}

verifgpg(){
  local id tempdir file
  id=$1
  tempdir=$2
  file=$3
  if [ "${file##*.}" = "gpg" ]; then
    # gpg -sign
    gpg --no-default-keyring --keyring "$tempdir/cert.0.gpg" --verify "$file" > /dev/null 2>&1 || return 1
  elif [ "${file##*.}" = "asc" ]; then
    # gpg --clearsign 
    gpg --no-default-keyring --keyring "$tempdir/cert.0.gpg" --verify "$file" > /dev/null 2>&1 || return 1
  elif [ -f "$file.asc" ]; then
    # gpg -a --detach-sig --sign
    gpg --no-default-keyring --keyring "$tempdir/cert.0.gpg" --verify "$file.asc" "$file" > /dev/null 2>&1 || return 1
  else
    # gpg --detach-sig --sign
    gpg --no-default-keyring --keyring "$tempdir/cert.0.gpg" --verify "$file.sig" "$file" > /dev/null 2>&1 || return 1
  fi
  return 0
}

verifopenssl(){
  local id tempdir file CAfile Leaf
  id=$1
  tempdir="$2"
  file="$3"

  if [ -f "$tempdir/cert.0" ] && grep -q "PUBLIC KEY-----" "$tempdir/cert.0"; then
    # We have directly a public key
    openssl dgst -verify "$tempdir/cert.0" -signature "$file.sig" -binary "$file" 2> /dev/null
  else
    for _file in "$tempdir"/*; do
      # Is the certificate the leaf certificate. If not add to CAFile
      if openssl x509 -inform pem -noout -ext keyUsage -in "$_file" 2>/dev/null | \
          grep -q -i "Certificate Sign"; then
        [ -z "$CAfile" ] && CAfile=$(mktemp)
        cat "$_file" >> "$CAfile"
      else
        Leaf="$_file"
      fi
    done
    # Verify the key chain
    # FIXME: At this point the complete key chain is needed
    openssl verify -CAfile "$CAfile" "$Leaf" || return 1

    # Extract the public key
    openssl x509 -pubkey -inform pem -in "$Leaf" -outform pem -out "$tempdir/pubkey"
    
    # Verify with the public key
    openssl dgst -verify "$tempdir/pubkey" -signature "$file.sig" -binary "$file"
  fi
  return $?
}

verifcyberwatch(){
  local id tempdir file zipdir status
  id=$1
  tempdir="$2"
  file="$3"
  zipdir=$(mktemp -d)

  # Unzip the file
  unzip -q -d "$zipdir" "$file"

  # Check the signature
  status=0
  head -c -1 "$zipdir/cyberwatch.sig" > "$tempdir/signature" 2> /dev/null || { /bin/rm -fr "$zipdir"; return 1; }
  head -c -1 "$zipdir/cyberwatch.db" | sha256sum | cut -f1 -d' ' | tr -d '\n' > "$tempdir/cyberwatch.db.sha256"
  openssl dgst -sha256 -verify "$tempdir/cert.0" -signature "$tempdir/signature" "$tempdir/cyberwatch.db.sha256" > /dev/null || status=1

  # Repack the zipfile so as to avoid potentially hidden files
  if [ "$status" = "0" ]; then
    if [ "$dryrun" = "1" ]; then
      echo "[DryRun]: cd \"$zipdir\"; zip -q \"$file.$$\" cyberwatch.sig cyberwatch.db"
    else
      # Use () to create sub-shell, so chdir is local to the sub-shell
      (cd "$zipdir" || { 2>&1 echo "Failed to create temporary directory"; return 254; }; zip -q "$file.$$" cyberwatch.sig cyberwatch.db)
      /bin/mv -f "$file.$$" "$file"
    fi
  fi
  /bin/rm -fr "$zipdir"

  return $status
}

verifliveupdate(){
  local id tempdir src file zipdir dest livetri 
  local sig grd g args s1 s256 f basedir s t last filedir
  id=$1
  tempdir="$2"
  src="$3"
  file="$4"
  zipdir="$5"
  dest="$6"
  livetri=$7

  unzip -d "$zipdir" "$src/$file" > /dev/null 2>&1 || 7z -o"$zipdir" x "$src/$file" > /dev/null 2>&1 
  sig=$(find "$zipdir" -name "*.sig")
  [ -n "$sig" ] || { 1>&2 myecho "File *.sig not found in the archive $(basename "$file")"; return 1; }

  # Assumes all of the CA are in $termpdir/cert.0 and the other certificates in $tempdir/cert.1
  args="-purpose any -no_check_time"
  [ -f "$tempdir/cert.0" ] && args="$args -CAfile $tempdir/cert.0"
  [ -f "$tempdir/cert.1" ] && args="$args -nointern -certfile $tempdir/cert.1"

  # Get base directory name
  basedir=$(dirname "$(find "$zipdir" -name "*.grd" | head -n1)")
    
  # Verify the signature of the  file *.grd...  
  for s in $sig; do
    # Special case v1.sig that is an alternative signature for v.sig
    [ "$(basename "$s")" = "v1.sig" ] && continue
    t=$(echo "$s" | sed -e 's/.sig$/.grd/g')
    [ -f "$t" ] || { 1>&2 myecho "Checksum file $(basename "$t") not found in the archive $(basename "$file")"; return 1; }
    # I want the variable $args to do word splitting, ignore 
    # the shellcheck error associated with it
    # shellcheck disable=SC2086    
    openssl cms -verify -inform DER -in "$s" -content "$t" $args > /dev/null 2>&1 || \
        { 1>&2 myecho "Verification failure of the file $(basename "$t") from the archive $(basename "$file") "; return 1; }
  done

  # Fail if there are any files in the archive not listed in a GRD file
  while IFS= read -r -d '' f; do
    f=${f#"$basedir/"}
    [[ "$f" =~ \.grd$ ]] && continue
    [[ "$f" =~ \.sig$ ]] && continue
    # FIXME The JDB files have the files lic.dat and navlic.dat that are not listed
    # in a grd file; What are these files ? How to check them ? For now we ignore
    # these files under three conditions:
    #    1. The file size is exactly 1048 bytes
    #    2. navlic.dat and lic.dat are the same file
    #    3. They are both listed in the catalog.dat file that is included in v.grd
    if [[ "$f" =~ lic.dat$ ]] || [[ "$f" =~ navlic.dat$ ]]; then
      [ "$(stat -c%s "$f")" = "1048" ] || { 1>&2 myecho "Can not verify the file $(basename "$f") from the archive $(basename "$file")"; return 1; }
      if [ ! -f "$basedir/lic.dat" ] || [ ! -f "$basedir/navlic.dat" ] || ! diff -q "$zipdir/lic.dat" "$zipdir/navlic.dat"; then
        1>&2 myecho "Can not verify the file $(basename "$f") from the archive $(basename "$file")"
        return 1
      fi
      grep -qi "$f" "$basedir/catalog.dat" || { 1>&2 myecho "Can not verify the file $(basename "$f") from the archive $(basename "$file")"; return 1; }
    else
      grd=""
      while IFS= read -r -d '' g; do
        grep -qi "$f" "$g" && { grd="$g"; break; }
      done < <(find "$basedir" -type f -name "*.grd" -print0)
      if [ -z "$grd" ]; then
        1>&2 myecho "Can not verify the file $(basename "$f") from the archive $(basename "$file")"; 
        return 1;
      fi
    fi
  done < <(find "$basedir" -type f -print0)

  s1=""
  s256=""
  f=""
  last=""
  filedir=$(dirname "$file")

  while IFS= read -r -d '' t; do
    while :; do
      IFS= read -r line || last="true"
      # If I do what shellcheck wants this code fails !!
      # shellcheck disable=SC2076
      if [ -n "$last" ] || [[ "$line" =~ "^\[File-.*\]" ]]; then
        if [ -n "$f" ] && [ -f "$basedir/$f" ]; then
          [ -z "$s256" ] || sha256sum "$basedir/$f" | grep -q "$s256" || \
              { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename "$file")"; return 2; }
          [ -z "$s1" ] || sha1sum "$basedir/$f" | grep -q "$s1" || \
              { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename "$file")"; return 2; }
          [ -z "$s256" ] && [ -z "$s1" ] && { 1>&2 myecho "File $f from the archive $(basename "$file") has no checksum"; return 2; }
        elif [ -n "$f" ] && [ -f "$src/$filedir/$f" ]; then
          # Only reverify the hash if its not already done.
          if [ ! "$src/$filedir/$f" -ef "$dest/$filedir/$f" ]; then
            [ -z "$s256" ] || sha256sum "$src/$filedir/$f" | grep -q "$s256" || \
                { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename "$file")"; return 2; }
            [ -z "$s1" ] || sha1sum "$src/$filedir/$f" | grep -q "$s1" || \
                { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename "$file")"; return 2; }
            [ -z "$s256" ] && [ -z "$s1" ] && { 1>&2 myecho "File $f from the archive $(basename "$file") has no checksum"; return 2; }
            if [ -n "$livetri" ]; then
              if [ "$antivirus" = "true" ]; then
                # Antivirus test
                clamdscan "$src/$filedir/$f" > /dev/null 2>&1 || { 1>&2 myecho "File $f from the archive $(basename "$file") failed anti-virus check";  return 4; }
              fi
              msgline "$src/$filedir/$f" 0
              ln "$src/$filedir/$f" "$dest/$filedir/$f"
            fi
          fi
        elif [ -n "$f" ]; then
          1>&2 echo "File $f not found. skipping"
        fi
        [ -z "$last" ] || break;
        f=$(echo "$line" | sed -e "s/^\[File-\(.*\)\]\s*$/\1/g")
        [ -f "$basedir/$f" ] || [ -f "$src/$filedir/$f" ] || f=$(echo "$f" | awk '{print tolower($0)}')
        s1=""
        s256=""
      elif [[ "$line" =~ ^SHA1=.* ]]; then
        s1=$(echo "$line" | sed -e "s/^SHA1=\([0-9a-fA-F]*\)\s*$/\1/g")
      elif [[ "$line" =~ ^SHA256=.* ]]; then
        s256=$(echo "$line" | sed -e "s/^SHA256=\([0-9a-fA-F]*\)\s*$/\1/g")
      fi
    done < "$t"
  done < <(find "$basedir" -type f -name "*.grd" -print0)

  # Repack the zip file before returning to avoid potentiel hidden files
  if [[ "${file##*.}" = "7z" ]]; then 
    if [ "$dryrun" = "0" ]; then
      (cd "$zipdir" || { 2>&1 echo "Failed to create temporary directory"; return 254; }; 7z a "$src/$file.$$" ./*)
      /bin/mv "$src/$file.$$" "$src/$file"
    else
      echo "[DryRun] : cd \"$zipdir\"; 7z a \"$src/$file.$$\" \*"
    fi
  else
    if [ "$dryrun" = "0" ]; then
      (cd "$zipdir"|| { 2>&1 echo "Failed to create temporary directory"; return 254; }; zip -q "$src/$file.$$" ./* > /dev/null 2>&1)
      /bin/mv -f "$src/$file.$$" "$src/$file"
    else
      echo "[DryRun] : cd \"$zipdir\"; zip -q \"$src/$file.$$\" \*"
    fi
  fi

  return 0
}

verifsmime() {
  local id tempdir file sig
  id=$1
  tempdir="$2"
  file="$3"
  sig="${file%.*}.sig"

  [ -f "$sig" ] || { 1>&2 myecho "Unsigned file"; return 255; }
  # Assumes all of the CA are in $tempdir/cert.0 and the other certificates in $tempdir/cert.1
  args="-purpose any"
  [ -f "$tempdir/cert.0" ] && args="$args -CAfile $tempdir/cert.0"
  [ -f "$tempdir/cert.1" ] && args="$args -nointern -certfile $tempdir/cert.1"
  # I want the variable $args to do word splitting, ignore 
  # the shellcheck error associated with it
  # shellcheck disable=SC2086    
  [ -f "$sig" ] && { openssl cms -verify -inform DER -in "$sig" -content "$file" $args > /dev/null 2>&1 || \
          { 1>&2 myecho "Verification failure of the file $file"; return 1; }; }

  return 0
}

verifjar() {
  local id tempdir src file zipdir dest sf _hash _sig md5 s1 s256 _file basedir filedir
  id=$1
  tempdir=$2
  src=$3
  file=$4
  zipdir=$5
  dest=$6

  unzip -d "$zipdir" "$src/$file" > /dev/null 2>&1 || 7z -o"$zipdir" x "$src/$file" > /dev/null 2>&1 \
      || { 1>&2 myecho "Failed to unzip archive"; return 1; }

  # Check that there is only one Manifest file and that each SF file corresponds to 
  # a *.RSA, *.DSA ou SIG-* file and that all other files are listed in the manifest
  manifest="";
  while IFS= read -r -d '' _file; do
    [ -z "$manifest" ] || { 1>&2 myecho "Two or more manifests in JAR file"; return 1; }
    manifest=$_file
    continue
  done < <(find "$zipdir" -name "MANIFEST.MF" -print0)
  [ -z "$manifest" ] && { 1>&2 myecho "No manifest in JAR file"; return 1; }

  hassign="false"
  while IFS= read -r -d '' _file; do
    [[ "$_file" =~ MANIFEST.MF$ ]] && continue
    [[ "$_file" =~ \.SF$ ]] && continue
    if [[ "$_file" =~ \.RSA$ ]]; then
      [ ! -f "${_file%.RSA}.SF" ] && { 1>&2 myecho "Orphan signature file $_file"; return 1; }
      hassign="true"
      continue
    fi
    if [[ "$_file" =~ \.DSA$ ]]; then
      [ ! -f "${_file%.DSA}.SF" ] && { 1>&2 myecho "Orphan signature file $_file"; return 1; }
      hassign="true"
      continue;
    fi
    if [[ "$_file" =~ ^SIG- ]]; then
      [ ! -f "${_file#SIG-}.SF" ] && { 1>&2 myecho "Orphan signature file $_file"; return 1; }
      hassign="true"
      continue;
    fi
    # The filename might be split over several lines and the Manifest might be in dos format
    dos2unix < "$manifest" | sed -z 's/\n //g' | grep -q "^Name: \s*${_file#"$zipdir"/}$" || \
        { 1>&2 myecho "Unsigned file ${_file#"$zipdir"/} in jar"; return 1; }
  done < <(find "$zipdir" -type f -print0)

  [ "$hassign" = "true" ] || { 1>&2 myecho "Unsigned jar file"; return 255; }

  # Assumes all of the CA are in $tempdir/cert.0 and the other certificates in $tempdir/cert.1
  args="-purpose any"
  [ -f "$tempdir/cert.0" ] && args="$args -CAfile $tempdir/cert.0"
  [ -f "$tempdir/cert.1" ] && args="$args -nointern -certfile $tempdir/cert.1"

  # Several signers are possible with a different *.SF per signer
  while IFS= read -r -d '' sf; do
    # Check hash of manifest.
    _hash=$(grep "\-Digest\-Manifest: " "$sf" | dos2unix | cut -d: -f2 | xargs | base64 -d | hexdump -e '16/1 "%02x"')
    if [ ${#_hash} -ge 64 ]; then
      [ "$(sha256sum "$manifest" | cut -f1 -d' ')" = "$_hash" ] || return 1
    elif [ ${#_hash} -ge 40 ]; then
      [ "$(sha1sum "$manifest" | cut -f1 -d' ')" = "$_hash" ] || return 1
    else 
      [ "$(md5sum "$manifest" | cut -f1 -d' ')" = "$_hash" ] || return 1
    fi

    # Treat *.RSA signatures
    _sig="${sf%.SF}.RSA"
    # shellcheck disable=SC2086 
    [ -f "$_sig" ] && { openssl cms -verify -inform DER -in "$_sig" -content "$sf" $args > /dev/null 2>&1 || \
          { 1>&2 myecho "Verification failure of the file ${sf#"$zipdir"/} from the archive $(basename "$file") "; return 1; }; }

    # Treat *.DSA signatures.  Not sure this is the right thing to do. 
    # Needs testing if I had a JAR with a DSA signature
    _sig="${sf%.SF}.DSA"
    # shellcheck disable=SC2086 
    [ -f "$_sig" ] && { openssl cms -verify -inform DER -in "$_sig" -content "$sf" $args > /dev/null 2>&1 || \
          { 1>&2 myecho "Verification failure of the file ${sf#"$zipdir"/} from the archive $(basename "$file") "; return 1; }; }

    # Don't treat SIG-* files. Trend doesn't use them and the format is too generic
    _sig="SIG-${sf%.SF}"
    [ -f "$_sig" ] && { 1>&2 myecho "Don't know how to treat $_sig file"; return 1; }
  done < <(find "$zipdir" -name "*.SF" -print0)

  # Now that the manifest is verified, check the hash of each file in the manifest
  filedir=$(dirname "$file")
  last=""
  s256=""
  s1=""
  md5=""
  while :; do
    IFS= read -r line || last=true   

    # shellcheck disable=SC2076
    if [ -n "$last" ] || [[ "$line" =~ "^Name:" ]]; then  
      [ -z "$last" ] && [ -z "$_file" ] && { _file=$(echo "$line" | dos2unix | sed -e "s/^Name: \(.*\)\s*$/\1/g"); continue; }
      if [ -f "$zipdir/$_file" ]; then
        [ -z "$s256" ] || sha256sum "$zipdir/$_file" | grep -q "$s256" || \
            { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
        [ -z "$s1" ] || sha1sum "$zipdir/$_file" | grep -q "$s1" || \
            { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
        [ -z "$md5" ] || md5sum "$zipdir/$_file" | grep -q "$md5" || \
            { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
        [ -z "$s256" ] && [ -z "$s1" ] && [ -z "$md5" ] && { 1>&2 myecho "File $_file from the archive $(basename "$file") has no checksum"; return 2; }
      elif [ -f "$src/$filedir/$_file" ]; then
        # Only reverify the hash if its not already done.
        if [ ! "$src/$filedir/$_file" -ef "$dest/$filedir/$_file" ]; then
          [ -z "$s256" ] || sha256sum "$src/$filedir/$_file" | grep -q "$s256" || \
              { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
          [ -z "$s1" ] || sha1sum "$src/$filedir/$_file" | grep -q "$s1" || \
              { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
          [ -z "$md5" ] || md5sum "$src/$filedir/$_file" | grep -q "$md5" || \
              { 1>&2 myecho "Verification of checksum failed for $_file from the archive $(basename "$file")"; return 2; }
          [ -z "$s256" ] && [ -z "$s1" ] && [ -z "$md5" ] && { 1>&2 myecho "File $_file from the archive $(basename "$file") has no checksum"; return 2; }
          if [ "$antivirus" = "true" ]; then
            # Antivirus test
            clamdscan "$src/$filedir/$_file" > /dev/null 2>&1 || { 1>&2 myecho "File $_file from the archive $(basename "$file") failed anti-virus check";  return 4; }
          fi
          msgline "$src/$filedir/$_file" 0
          ln "$src/$filedir/$_file" "$dest/$filedir/$_file"
        fi
      else
        1>&2 echo "File $_file not found. skipping"
      fi

      [ -z "$last" ] || break;
      _file=$(echo "$line" | dos2unix | sed -e "s/^Name: \(.*\)\s*$/\1/g")
      md5=""
      s1=""
      s256=""
    elif [[ "$line" =~ ^SHA-1-.* ]]; then
      s1=$(echo "$line" | dos2unix | cut -d: -f2 | xargs | base64 -d | hexdump -e '16/1 "%02x"')
    elif [[ "$line" =~ ^SHA-256-.* ]]; then
      s256=$(echo "$line" | dos2unix | cut -d: -f2 | xargs | base64 -d | hexdump -e '16/1 "%02x"')
    elif [[ "$line" =~ ^MD5-.* ]]; then
      md5=$(echo "$line" | dos2unix | cut -d: -f2 | xargs | base64 -d | hexdump -e '16/1 "%02x"')
    fi
  done <  <(sed -z 's/\n //g ' "$manifest")

  if [[ "${file##*.}" = "7z" ]]; then 
    if [ "$dryrun" = "0" ]; then
      (cd "$zipdir" || { 2>&1 echo "Failed to create temporary directory"; return 254; }; 7z -r a "$src/$file.$$" ./*)
      /bin/mv "$src/$file.$$" "$src/$file"
    else
      echo "[DryRun] : cd \"$zipdir\"; 7z -r a \"$src/$file.$$\" \*"
    fi
  else
    if [ "$dryrun" = "0" ]; then
      (cd "$zipdir"|| { 2>&1 echo "Failed to create temporary directory"; return 254; }; zip -qr "$src/$file.$$" ./* > /dev/null 2>&1 )
      /bin/mv -f "$src/$file.$$" "$src/$file"
    else
      echo "[DryRun] : cd \"$zipdir\"; zip -qr \"$src/$file.$$\" \*"
    fi
  fi

  return 0
}

verifdirectory() {
  local file status i j fprint tempdir idx auth id dir type
  id=$1
  dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  dir=${dir%/}
  type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" "$CONF")
  
  # Validate check type
  case $type in
    authenticode|openssl|gpg|liveupdate|cyberwatch|jar|trend) : ;;
    *) 1>&2 echo "Unknown file checking type"; exit 1 ;;
  esac

  tempdir=$(mktemp -d)
  i=1
  j=1
  while :; do
    fprint=$(xmllint --xpath "string(dsas/tasks/task[$id]/cert[$j]/fingerprint)" "$CONF")
    [ -z "$fprint" ] && break;
    idx=$($getcert "$fprint" $$)
    [ -z "$idx" ] && { 1>&2 echo "Certificate used by task($id) not found !!"; cleanup_and_exit 1 "$tempdir"; }
    if [ "$idx" -eq 0 ]; then
      if [ "$type" = "liveupdate" ] || [ "$type" = "trend" ]; then
        cat /tmp/cert.$$ >> "$tempdir/cert.0"
      else
        [ -f "$tempdir/cert.0" ] && 1>&2 myecho "Multiple authority certificates defined" 
        /bin/mv "/tmp/cert.$$" "$tempdir/cert.0"
      fi
    else
      auth=$(xmllint --xpath "string(dsas/certificates/certificate[$idx]/authority)" "$CONF")
      if [ "$auth" = "true" ]; then
        if [ "$type" = "liveupdate" ] || [ "$type" = "trend" ]; then
          cat "/tmp/cert.$$" >> "$tempdir/cert.0"
        else
          [ -f "$tempdir/cert.0" ] && 1>&2 myecho "Multiple authority certificates defined"
          /bin/mv "/tmp/cert.$$" "$tempdir/cert.0"
        fi
      else
        if [ "$type" = "liveupdate" ] || [ "$type" = "trend" ]; then
          cat "/tmp/cert.$$" >> "$tempdir/cert.1"
        else
          /bin/mv -f "/tmp/cert.$$" "$tempdir/cert.$i"
          i=$((i+1))
        fi
      fi
    fi
    j=$((j + 1))
  done
  if [ "$type" = "gpg" ]; then
    # Need to dearmor gpg certificate before use
    gpg --dearmor "$tempdir/cert.0" > /dev/null 2>&1
  fi

  # Create directory if needed
  [ -d "$DSAS_BAS/$dir" ] || mkdir "$DSAS_BAS/$dir"
  
  # Remove the files in our tree bas and not in haut.
  while IFS= read -r -d '' file; do
    if [ "$(stat --printf "%h\n"  "$file")" = "1" ]; then
      1>&2 myecho "Removing stale file ${file#"$DSAS_BAS/${dir%/}/"}"
      rm -f "$file"
    fi
  done < <(find "$DSAS_BAS/$dir" -type f -print0)

  # If LiveUpdate, test files *livetri.zip first as they can sign other files
  if [ "$type" = "liveupdate" ]; then        
    while IFS= read -r -d '' file; do
      file=${file#"$DSAS_HAUT/"}    
    
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$file" -ef "$DSAS_BAS/$file" ] && continue

      zipdir=$(mktemp -d)
      if [[ "$file" = "*livetri.zip" ]]; then
        verifliveupdate "$id" "$tempdir" "$DSAS_HAUT" "$file" "$zipdir" "$DSAS_BAS" "true"
      elif [[ "$file" = "*minitri.flg" ]]; then
        # minitri.flg is one byte with a single 0x20 character
        [ "$(cat "$DSAS_HAUT/$file")" = " " ]
      else
        verifliveupdate "$id" "$tempdir" "$DSAS_HAUT" "$file" "$zipdir" "$DSAS_BAS"
      fi
      status=$?
      if [ "$status" = "0" ] && [ "$antivirus" = "true" ]; then
        clamdscan "$DSAS_HAUT/$file" > /dev/null 2>&1 || status=4
      fi
      msgline "$DSAS_HAUT/$file" $status
      [ $status -eq 0 ] && ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
      /bin/rm -fr "$zipdir"
    done < <(find "$DSAS_HAUT/$dir" -type f \( -name "*livetri.zip" -o -name "minitri.flg" \
        -o -name "SymantecProductCatalog.zip" -o -name "*.jdb" \) -print0)
  elif [ "$type" = "trend" ] || [ "$type" = "jar" ]; then
   while IFS= read -r -d '' file; do
      file=${file#"$DSAS_HAUT/"}    
    
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$file" -ef "$DSAS_BAS/$file" ] && continue

      if [ "$type" = "trend" ] &&  [ "${file##.*}" = "xml" ]; then
        # Trend micro XML files must adhere to a strict XSD Schema
        if xmllint --noout --schema "$SCHEMA" "$DSAS_HAUT/$file" > /dev/null 2>&1 ; then
          status=0
          if [ "$antivirus" = "true" ]; then
            clamdscan "$DSAS_HAUT/$file" > /dev/null 2>&1 || status=4
          fi
        else
          status=$?
        fi
      elif [ "$type" = "trend" ] && [ -z "$(zipinfo "$DSAS_HAUT/$file" 2> /dev/null | grep -q MANIFEST.MF && echo "1")" ] ; then
        # SMIME signed files
        if verifsmime "$id" "$tempdir" "$file"; then
          status=0
          if [ "$antivirus" = "true" ]; then
            clamdscan "$DSAS_HAUT/$file" > /dev/null 2>&1 || status=4
          fi
        else
          status=$?
        fi
      else
        # JAR file 
        zipdir=$(mktemp -d)
        verifjar "$id" "$tempdir" "$DSAS_HAUT" "$file" "$zipdir" "$DSAS_BAS"
        status=$?
        if [ "$status" = "0" ] && [ "$antivirus" = "true" ]; then
          clamdscan "$DSAS_HAUT/$file" > /dev/null 2>&1 || status=4
        fi
        /bin/rm -fr "$zipdir"
      fi
      [ $status -eq 0 ] && ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
      [ $status -eq 0 ] && [ "$type" = "trend" ] && [ -f "$DSAS_HAUT/${file%.*}.sig" ] \
          && ln "$DSAS_HAUT/${file%.*}.sig" "$DSAS_BAS/${file%.*}.sig"
      msgline "$DSAS_HAUT/$file" $status
    done < <(find "$DSAS_HAUT/$dir" -type f \( -name "*.7z" -o -name "*.zip" -o -name "*.jar" \) -print0)
  else
    while IFS= read -r -d '' file; do
      file=${file#"$DSAS_HAUT/"}    
    
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$file" -ef "$DSAS_BAS/$file" ] && continue

      case $type in
        authenticode) verifauthenticode "$id" "$tempdir" "$DSAS_HAUT/$file" ;;
        cyberwatch)
          [ "${file##*.}" != "zip" ]  && msgline "$DSAS_HAUT/$file" 255 && continue 
          verifcyberwatch "$id" "$tempdir" "$DSAS_HAUT/$file"
          ;;
        openssl) 
          [ "${file##*.}" = "sig" ]  && continue 
          verifopenssl "$id" "$tempdir" "$DSAS_HAUT/$file"
          ;;
        gpg)
          [ "${file##*.}" = "sig" ] && continue
          [ "${file##*.}" = "asc" ] && [ -f "$DSAS_HAUT/$(dirname "$file")/$(basename -s .asc "$file")" ] && continue
          verifgpg "$id" "$tempdir" "$DSAS_HAUT/$file"
          ;;
      esac
      status=$?
      if [ "$status" = "0" ] && [ "$antivirus" = "true" ]; then
        clamdscan "$DSAS_HAUT/$file" > /dev/null 2>&1 || status=4
      fi
      msgline "$DSAS_HAUT/$file" $status
      if [ $status -eq 0 ]; then
        ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
        if [ "$type" = "gpg" ] && [ "${file##*.}" != "gpg" ]; then
          if [ -f "$DSAS_HAUT/$file.asc" ]; then
            ln "$DSAS_HAUT/$file.asc" "$DSAS_BAS/$file.asc"
          elif [ -f "$DSAS_HAUT/$file.sig" ]; then
            ln "$DSAS_HAUT/$file.sig" "$DSAS_BAS/$file.sig"
          fi
        fi
        [ "$type" = "openssl" ] && ln "$DSAS_HAUT/$file.sig" "$DSAS_BAS/$file.sig"
      fi
    done < <(find "$DSAS_HAUT/$dir" -type f -print0 )
  fi
  /bin/rm -fr "$tempdir"

  # There might be empty directories lying about. Remove them
  while IFS= read -r -d '' _dir; do
    [ "$(ls -A "$_dir")" ] || { 1>&2 echo "Removing empty directory $_dir"; rmdir "$_dir"; }
  done < <(find "$DSAS_BAS/$dir" -mindepth 1 -type d -print0 )

}

checkrpm(){
  # Unsigned RPM files pass the test "rpm -K", so have to explicitly test for them
  rpm -qi "$1" 2> /dev/null | grep -q "^Signature.*:.*(none)$" && return 1
  rpm -K "$1" > /dev/null 2>&1 || return 1
  return 0
}

verify_packages() {
  local file chktype chksum dir rpm_k
  dir=$1
  rpm_k=$2
  shift 2
  while [ "$#" -gt 2 ]; do
    if [ "${1: -3}" = "rpm" ]; then
      file="$1"
      chktype=$2
      chksum=$3
    else
      file="$3"
      chktype=$1
      chksum=$2
    fi
    shift 3

    # If file exists in bas skip. Hardlinked, so test is fast
    [ "$DSAS_HAUT/$dir/$file" -ef "$DSAS_BAS/$dir/$file" ] && continue

    if [ -f "$DSAS_HAUT/$dir/$file" ]; then
      if  check_checksum "$DSAS_HAUT/$dir/$file" "$chksum" "$chktype"; then
        msgline "$DSAS_HAUT/$dir/$file" 2
      elif [ "$rpm_k" = "1" ] && ! checkrpm "$DSAS_HAUT/$dir/$file"; then
        msgline "$DSAS_HAUT/$dir/$file" 5      
      elif [ "$antivirus" = "true" ]; then
        if rpm2cpio "$DSAS_HAUT/$dir/$file" | clamdscan - > /dev/null 2>&1; then
          msgline "$DSAS_HAUT/$dir/$file" 0
          ln "$DSAS_HAUT/$dir/$file" "$DSAS_BAS/$dir/$file"
        else
          msgline "$DSAS_HAUT/$dir/$file" 4
        fi
      else
        msgline "$DSAS_HAUT/$dir/$file" 0
        ln "$DSAS_HAUT/$dir/$file" "$DSAS_BAS/$dir/$file"
      fi
    fi  # For now ignore missing files
  done
}

verifrepo() {
  local tempdir fprint idx filelist chksum chktype filetable id dir type
  id=$1
  dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  dir=${dir%/}
  type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" "$CONF")

  tempdir=$(mktemp -d)
  fprint=$(xmllint --xpath "string(dsas/tasks/task[$id]/cert[1]/fingerprint)" "$CONF")
  idx=$($getcert "$fprint" $$)
  [ -z "$idx" ] && { 1>&2 echo "Certificate used by task\($id\) not found !!"; exit 1; }
  /bin/mv "/tmp/cert.$$" "$tempdir/cert.0"
  gpg --dearmor "$tempdir/cert.0" > /dev/null 2>&1

  if [ "$type" = "repomd" ]; then
    if ! gpg --no-default-keyring --keyring "$tempdir/cert.0.gpg"  \
          --verify "$DSAS_HAUT/$dir/repodata/repomd.xml.asc" \
          "$DSAS_HAUT/$dir/repodata/repomd.xml" > /dev/null 2>&1; then
      1>&2 echo "Failed to verify repomd.xml signature"
      exit 1
    fi
  else
    # For rpm signature verification need to import GPG key
    rpm --import "$tempdir/cert.0" > /dev/null 2>&1
  fi 

  # Create the destination directory if needed
  [ -d "$DSAS_BAS/$dir" ] || mkdir "$DSAS_BAS/$dir"

  # Test antivirus 
  if [ "$antivirus" = "true" ]; then
    clamdscan "$DSAS_HAUT/$dir/repodata/repomd.xml" > /dev/null 2>&1 || { msgline "$DSAS_HAUT/$dir/repodata/repomd.xml" 4; exit 1; }
  fi

  # Copy repomd.xml* to $bas
  ln "$DSAS_HAUT/$dir/repodata/repomd.xml" "$DSAS_BAS/$dir/repodata/repomd.xml"
  [ -f "$DSAS_HAUT/$dir/repodata/repomd.xml.asc" ] && ln "$DSAS_HAUT/$dir/repodata/repomd.xml.asc" "$DSAS_BAS/$dir/repodata/repomd.xml.asc"

  # Remove files in repodata not listed in repomd.xml
  while IFS= read -r -d '' _file; do
    _f=$(basename "$_file")
    [[ "$_f" =~ repomd.xml$ ]] && continue
    grep "$_f" "$DSAS_BAS/$dir/repodata/repomd.xml" && continue
    myecho "Removing stale file repodata/${_f}"
    rm -f "$_file"
  done < <(find "$DSAS_BAS/$dir/repodata" -type f)

  # Verify the checksum of all files referenced in repomd.xml and copy to $bas
  i=1
  while :; do
    # Note that we have to ignore the xml namespace (initial cat/sed)
    f=$(sed -e "s:repomd xmlns:repomd ignore:g" "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
         xmllint --xpath "string(//repomd/data[$i]/location/@href)" -)
    [ -z "$f" ] && break

    # Verify its checksum
    chksum=$(sed -e "s:repomd xmlns:repomd ignore:g" "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
         xmllint --xpath "string(//repomd/data[$i]/checksum)" - )
    chktype=$(sed -e "s:repomd xmlns:repomd ignore:g" "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
         xmllint --xpath "string(//repomd/data[$i]/checksum/@type)" - )
    if  check_checksum "$DSAS_HAUT/$dir/$f" "$chksum" "$chktype"; then
      1>&2 echo "Error verifying checksum of $f"
      cleanup_and_exit 1 "$tempdir"
    fi

    # Test antivirus 
    if [ "$antivirus" = "true" ]; then
      clamdscan "$DSAS_HAUT/$dir/$f" > /dev/null 2>&1 || { 1>&2 echo "The file $f fails the antivirus test"; cleanup_and_exit 4 "$tempdir"; }
    fi

    ln "$DSAS_HAUT/$dir/$f" "$DSAS_BAS/$dir/$f"
    i=$((i + 1))
  done

  # Identify the primary file list
  # Note that we have to ignore the xml namespace (initial cat/sed)
  filelist=$(sed -e "s:repomd xmlns:repomd ignore:g" "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
         xmllint --xpath 'string(//repomd/data[@type="primary"]/location/@href)' -)

  # Recover a table of the hashtype, hash and file names
  if [[ "$filelist" =~ \.gz$ ]] || [[ "$filelist" =~ \.bz2$ ]]; then
    filetable=$(zcat "$DSAS_HAUT/$dir/$filelist" | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
  else
    filetable=$(sed -e "s/xmlns=/ignore=/g" "$DSAS_HAUT/$dir/$filelist" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
  fi

  # Remove the files in $DSAS_BAS and not listed in primary.xml
  while IFS= read -r -d '' file; do
    if [ "$(stat --printf "%h\n"  "$file")" = "1" ]; then
      1>&2 myecho "Removing stale file ${file#"$DSAS_BAS/${dir%/}/"}"
      rm -f "$file"
    fi
  done < <(find "$DSAS_BAS/$dir" -path ./repodata -prune -type f -o -type f -print0)

  # Verify the packages
  # I want the variable $filetable to do word splitting, ignore 
  # the shellcheck error associated with it
  # shellcheck disable=SC2086 
  [ "$type" = "rpm" ] && verify_packages "$dir" 1 $filetable
  # shellcheck disable=SC2086 
  [ "$type" = "rpm" ] || verify_packages "$dir" 0 $filetable
  
  # Remove all RPM signature keys    
  [ "$type" = "rpm" ] && rpm -e "$(rpm -qa)" 2> /dev/null

  /bin/rm -fr "$tempdir"
}

verifdeb(){
  local chktyp inhash hashtyp _hash _hash_md5 _hash_sha256 _arch _file 
  local j pool have_pool packages tempdir archs i _f package id dir type
  id=$1
  dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  dir=${dir%/}
  type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" "$CONF")

  pool=$(dirname "$dir")
  have_pool="0"
  while [ -n "$pool" ]; do
    [ -d "$DSAS_HAUT/$pool/pool" ] && have_pool="1" && break
    pool=$(dirname "$pool")
  done
  [ "$have_pool" = "0" ] && { 1>&2 echo "Debian pool directory not found"; exit 1; }

  tempdir=$(mktemp -d)
  j=1
  while :; do
    fprint=$(xmllint --xpath "string(dsas/tasks/task[$id]/cert[$j]/fingerprint)" "$CONF")
    [ -z "$fprint" ] && break;
    idx=$($getcert "$fprint" $$)
    [ -z "$idx" ] && { 1>&2 echo "Certificate used by task($id) not found !!"; cleanup_and_exit 1 "$tempdir"; }
    gpg --no-default-keyring --keyring "$tempdir/keyring.gpg" --import /tmp/cert.$$ > /dev/null 2>&1
    j=$((j + 1))
  done

  if ! gpg --no-default-keyring --keyring "$tempdir/keyring.gpg"  \
        --verify "$DSAS_HAUT/$dir/Release.gpg" \
        "$DSAS_HAUT/$dir/Release" > /dev/null 2>&1 ; then
    1>&2 echo "Failed to verify Release signature"
    cleanup_and_exit 1 "$tempdir"
  fi
  if ! gpg --no-default-keyring --keyring "$tempdir/keyring.gpg"  \
        --verify "$DSAS_HAUT/$dir/InRelease" > /dev/null 2>&1 ; then
    1>&2 echo "Failed to verify InRelease signature"
    cleanup_and_exit 1 "$tempdir"
  fi

  if [ "$antivirus" = "true" ]; then
    clamdscan "$DSAS_HAUT/$dir/Release" > /dev/null 2>&1 || { 1>&2 echo "The file Release failed antivirus check"; cleanup_and_exit 4 "$tempdir"; }
    clamdscan "$DSAS_HAUT/$dir/InRelease" > /dev/null 2>&1 || { 1>&2 echo "The file InRelease failed antivirus check"; cleanup_and_exit 4 "$tempdir"; }
  fi

  # Create the destination directory if needed
  [ -d "$DSAS_BAS/$dir" ] || mkdir "$DSAS_BAS/$dir"

  # Copy *Release* to $bas
  for _file in Release Release.gpg InRelease; do
    [ -f "$DSAS_HAUT/$dir/$_file" ] && ln "$DSAS_HAUT/$dir/$_file" "$DSAS_BAS/$dir/$_file"
  done

  # Identify if the Release file has SHA256 et/ou MD5 hashes
  grep -qx "MD5Sum:" "$DSAS_HAUT/$dir/Release" && hashtyp="MD5Sum:" && chktyp="md5"
  grep -qx "SHA1:" "$DSAS_HAUT/$dir/Release" && hashtyp="SHA1:" && chktyp="sha"
  grep -qx "SHA256:" "$DSAS_HAUT/$dir/Release" && hashtyp="SHA256:" && chktyp="sha256"

  # Get the desired archiectures to download
  archs=""
  i=1
  while :; do
    _arch=$(xmllint --xpath "string(dsas/tasks/task[$id]/archs/arch[$i])" "$CONF")
    [ -z "$_arch" ] && break;
    archs="$archs $_arch"
    i=$((i + 1))
  done 

  # Identify all files listed in Release and download them
  inhash=0
  while read -r line; do
    # Assume that each hash is listed after the correct flag and has
    # a leading space
    [ "$inhash" = "0" ] && [[ "$line" =~ ^$hashtyp$ ]] && inhash="1" && continue
    [ "$inhash" = "1" ] && [[ "$line" =~ ":$" ]] && inhash="0" && continue
    [ "$inhash" = "0" ] && continue

    IFS=' ' read -r _hash _ _file << EOF
$line
EOF
    if [ -f "$DSAS_HAUT/$dir/$_file" ]; then
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$dir/$_file" -ef "$DSAS_BAS/$dir/$_file" ] && continue

      # Only check Package, Package.gz and Package.xz files if desired architecture 
      _f=$(basename "$_file")
      if [ "$_f" = "Packages" ] || [ "$_f" = "Packages.gz" ] || [ "$_f" = "Packages.xz" ]; then
        _f=$(dirname "$_file")
        [[ "$archs" =~ ${_f##*-} ]] || continue
      fi

      if  check_checksum "$DSAS_HAUT/$dir/$_file" "$_hash" "$chktyp"; then
        msgline "$DSAS_HAUT/$dir/$_file" 2  
      else
        [ -d "$(dirname "$DSAS_BAS/$dir/$_file")" ] || mkdir "$(dirname "$DSAS_BAS/$dir/$_file")"
        if [ "$antivirus" = "true" ]; then
          if clamdscan "$DSAS_HAUT/$dir/$_file" > /dev/null 2>&1 ; then
            msgline "$DSAS_HAUT/$dir/$_file" 0
            ln "$DSAS_HAUT/$dir/$_file" "$DSAS_BAS/$dir/$_file"
          else
            msgline "$DSAS_HAUT/$dir/$_file" 4
          fi
        else
          msgline "$DSAS_HAUT/$dir/$_file" 0
          ln "$DSAS_HAUT/$dir/$_file" "$DSAS_BAS/$dir/$_file"
        fi
      fi
      # For now ignore missing files
    fi
  done < "$DSAS_HAUT/$dir/Release"

  # For each file Packages.gz, and maybe Sources.gz, download the listed files 
  # into the pool directory
  packages=$(find "$DSAS_BAS/$dir" -name "Packages.gz")
  [[ "$archs" =~ "source" ]] && packages="$packages $(find "$DSAS_BAS/$dir" -name "Sources.gz")"
  for package in $packages; do
    _file=""
    _hash_md5=""
    _hash_sha256=""
    zcat "$package" | while read -r line; do
      # Use sed rather than xargs to strip leading/trailing whitespace as strings might
      # contain quotes and other special characters
      [[ "$line" =~ "Filename:" ]] && _file="$(echo "$line" | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
      [[ "$line" =~ "MD5sum:" ]] && _hash_md5="$(echo "$line" | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
      [[ "$line" =~ "SHA256:" ]] && _hash_sha256="$(echo "$line" | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
      if [ -z "$(echo "$line" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" ]; then
        if [ -f "$DSAS_HAUT/$pool/$_file" ]; then
          # If file exists in bas skip. Hardlinked, so test is fast
          [ "$DSAS_HAUT/$pool/$_file" -ef "$DSAS_BAS/$pool/$_file" ] && continue

          # Only test hash with one of the two hashes
          status=0
          if [ -n "$_hash_sha256"  ]; then
            if check_checksum "$DSAS_HAUT/$pool/$_file" "$_hash_sha256" "sha256"; then
              status=2
              msgline "$DSAS_HAUT/$pool/$_file" 2
            fi
          elif check_checksum "$DSAS_HAUT/$pool/$_file" "$_hash_md5" "md5"; then
            status=2
            msgline "$DSAS_HAUT/$pool/$_file" 2
          fi

          if [ "$status" -eq 0 ]; then
            [ -d "$(dirname i"$DSAS_BAS/$pool/$_file")" ] || mkdir "$(dirname "$DSAS_BAS/$pool/$_file")"

            if [ "$antivirus" = "true" ]; then
              status=0
              # clamav won't recognize the stream type if just "ar p" is used.
              # Need to treat each file in the archive individually
              while read -r _df; do
                ar p "$DSAS_HAUT/$pool/$_file" "$_df" | clamdscan - > /dev/null 2>&1 || { status=4; break; }
              done < <(ar t "$DSAS_HAUT/$pool/$_file")
              if [ "$status" = "0" ]; then
                msgline "$DSAS_HAUT/$pool/$_file" 0
                ln "$DSAS_HAUT/$pool/$_file" "$DSAS_BAS/$pool/$_file"
              else
                msgline "$DSAS_HAUT/$pool/$_file" 4
              fi
            else
              msgline "$DSAS_HAUT/$pool/$_file" 0 
              ln "$DSAS_HAUT/$pool/$_file" "$DSAS_BAS/$pool/$_file"
            fi
          fi
        fi
        _file=""
        _hash_md5=""
        _hash_sha256=""
      fi
    done
  done

  exit 0
}

passdirectory(){
  local file status i j fprint tempdir idx auth pool have_pool id dir
  id=$1
  dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  dir=${dir%/}

  if [ "$2" = "deb" ]; then
    pool=$(dirname "$dir")
    have_pool="0"
    while [ -n "$pool" ]; do
      [ -d "$DSAS_HAUT/$pool/pool" ] && have_pool="1" && break
      pool=$(dirname "$pool")
    done
    [ "$have_pool" = "0" ] && { 1>&2 echo "Debian pool directory not found"; exit 1; }
  fi

  # Create directory if needed
  while IFS= read -r -d '' _d; do
    _d=${_d#"$DSAS_HAUT/"}   
    [ -d "$DSAS_BAS/$_d" ] || mkdir "$DSAS_BAS/$_d"
  done < <(find "$DSAS_HAUT/$dir" -type d -print0)

  # Remove the files in our tree bas and not in haut.
  while IFS= read -r -d '' file; do
    if [ "$(stat --printf "%h\n"  "$file")" = "1" ]; then
      1>&2 myecho "Removing stale file ${file#"$DSAS_BAS/${dir%/}/"}"
      rm -f "$file"
    fi
  done < <(find "$DSAS_BAS/$dir" -type f -print0)

  while IFS= read -r -d '' file; do
    file=${file#"$DSAS_HAUT/"}
    # If file exists in bas skip. Hardlinked, so test is fast
    [ "$DSAS_HAUT/$file" -ef "$DSAS_BAS/$file" ] && continue

    # Don't log the transfers with msgline for the machine haut as
    # the logs aren't yet used
    1>&2 myecho "ln '$DSAS_HAUT/$file' '$DSAS_BAS/$file'"
    ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
  done < <(find "$DSAS_HAUT/$dir" -type f -print0)

  if [ "$2" = "deb" ]; then
    # Create directories if needed
    while IFS= read -r -d '' _d; do
      _d=${_d#"$DSAS_HAUT/"}  
      [ -d "$DSAS_BAS/$_d" ] || mkdir "$DSAS_BAS/$_d"
    done < <(find "$DSAS_HAUT/$pool/pool" -type d -print0)

    # Remove the files in our tree bas and not in haut.
    while IFS= read -r -d '' file; do
      if [ "$(stat --printf "%h\n"  "$file")" = "1" ]; then
        1>&2 myecho "Removing stale file ${file#"$DSAS_BAS/$pool/pool/"}"
        rm -f "$file"
      fi
    done < <(find "$DSAS_BAS/$pool/pool" -type f -print0)

    while IFS= read -r -d '' file; do
      file=${file#"$DSAS_HAUT/"}
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$file" -ef "$DSAS_BAS/$file" ] && continue

      # Don't log the transfers with msgline for the machine haut as
      # the logs aren't yet used
      1>&2 myecho "ln '$DSAS_HAUT/$file' '$DSAS_BAS/$file'"
      ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
    done < <(find "$DSAS_HAUT/$pool/pool" -type f -print0)
  fi

  # There might be empty directories lying about. Remove them
  while IFS= read -r -d '' _dir; do
    [ "$(ls -A "$_dir")" ] || { 1>&2 echo "Removing empty directory $_dir"; rmdir "$_dir"; }
  done < <(find "$DSAS_BAS/$dir" -mindepth 1 -type d -print0 )
}

verifclamav(){
  local dir="ClamAV"

  # Return if antivirus is not active
  [ "$antivirus" = "true" ] || return

  # Create directory if needed
  [ -d "$DSAS_BAS/$dir" ] || mkdir "$DSAS_BAS/$dir"
  
  if [ "$TYP" = "haut" ]; then
    for file in main.cvd daily.cvd bytecode.cvd; do
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$dir/$file" -ef "$DSAS_BAS/$dir/$file" ] && continue

      # Don't log the transfers with msgline for the machine haut as
      # the logs aren't yet used
      ln "$DSAS_HAUT/$dir/$file" "$DSAS_BAS/$dir/$file"
    done
  else
    for file in main.cvd daily.cvd bytecode.cvd; do
      # If file exists in bas skip. Hardlinked, so test is fast
      [ "$DSAS_HAUT/$dir/$file" -ef "$DSAS_BAS/$dir/$file" ] && continue

      # Verify the signature of the ClamAV signatures, with ClamAV itself
      if sigtool -i "$DSAS_HAUT/$dir/$file" > /dev/null 2>&1; then
        msgline "$DSAS_HAUT/$dir/$file" $?
        ln "$DSAS_HAUT/$dir/$file" "$DSAS_BAS/$dir/$file"
      else
        msgline "$DSAS_HAUT/$dir/$file" $?
      fi
    done
  fi
}

# Parse options
ids=""
while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose) verbose=1 ;;
    -q|--quiet) verbose=0 ;;
    -n|--dryrun) dryrun=1 ;;
    -c|--clamav) clamav=1 ;;
    -s|--stdout) logstdout=1 ;;
    -l|--log) logstdout=0 ;;
    -o) logfile=$2; shift 1 ;;
    --out=*) logfile=${1#*=} ;;
    -h|--help) help; exit 0 ;;
    -*) 1>&2 echo "Unrecognized option : $1"; help; exit 1 ;;
    *) 
      [ -n "$ids" ] && { 1>&2 echo "Only a single task is allowed"; exit 1; }
      ids="$ids $1" 
      ;;
  esac
  shift 1
done

# Check existence of DSAS directories
[ -d "$DSAS_HOME" ] || { echo "DSAS home directory missing"; exit 1; }
[ -d "$DSAS_BAS" ] || { echo "DSAS bas directory missing"; exit 1; }

# If dryrun, force verbose
[ $dryrun -ne 0 ] && verbose=1

# If ClamAV download request do it now and exit
antivirus="$(xmllint --xpath "string(dsas/config/antivirus/active)" "$CONF")"
[ "$clamav" = "1" ] && (verifclamav; exit 0)

# Check that all ids are valid before doing anything
idx=""
for _id in $ids; do
  if [ ${#_id} -lt 5 ] && [[ $_id =~ ^[0-9]+$ ]]; then
    _idx=$(xmllint --xpath "string(dsas/tasks/task[$_id]/id)" "$CONF")
    [ -z "$_idx" ] && { 1>&2 echo "Task id ($_id) does not exist"; exit 1; }
    idx="$idx $_id"
  else
    _idx=$(task_id_to_idx "$_id") || { 1>&2 echo "Task id\($_id\) does not exist"; exit 1; }
    idx="$idx $_idx"
  fi
done

for _id in $idx; do
  type=$(xmllint --xpath "string(dsas/tasks/task[$_id]/type)" "$CONF")
  if [ "$TYP" = "haut" ]; then
    # No verification on the machine haut
    passdirectory "$_id" "$type"
  else
    case $type in
      rpm|repomd) verifrepo "$_id"; ;;
      deb) verifdeb "$_id"; ;;
      authenticode|openssl|gpg|liveupdate|cyberwatch|trend|jar) verifdirectory "$_id"; ;; 
      *) 1>&2 echo "Unknown task type : $type"; exit 1 ;;
    esac
  fi
done
