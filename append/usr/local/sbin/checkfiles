#! /bin/sh

if [ -f "$(dirname $0)/dsas_common.sh" ]; then
  . $(dirname $0)/dsas_common.sh
else
  1>&2 echo "Common functions not found !!"
  exit -1
fi

# Default options
logfile="$LOG/dsas_verif.log"
UMASK=640

help() {
  echo "Usage: $(basename $0)  [Options] ID [ID...]"
  echo "Verify files given by the task ID."
  echo "     -v|--verbose    Log all files verified"
  echo "     -q|--quiet      Log only files failing to verifiy"
  echo "     -n|--dryrun     Perform no actions"
  echo "     -s|--stdout     Send logs to stdout"
  echo "     -l|--log        Send the logs to a file"
  echo "     -o <FILE>       Log to <FILE>, default $logfile"
  echo "     --out=<FILE>    Log to <FILE>"
  echo "     -?|-h|--help    Print this help"
}

cleanup_and_exit() {
  status=$1
  shift
  while [ "$#" -gt 0 ]; do
    rm -fr $1
    shift
  done
  exit $status
}

verifauthenticode(){
  local fingerprint
  local id=$1
  local tempdir=$2
  local file=$3

  if [ -f "$tempdir/cert.0" ]; then
    osslsigncode verify -CAfile $tempdir/cert.0 $file 2>&1 > /dev/null || return $?
  else
    osslsigncode verify $file 2>&1 > /dev/null || return $?
  fi

  for _file in $(ls $tempdir); do
    [ "$(basename $_file)" == "cert.0" ] && continue
    hash=$(openssl x509 -in $tempdir/$_file -noout -fingerprint -sha256 -inform pem 2>&1 | cut -d= -f2 | sed -e "s/://g" | tr "[A-Z]" "[a-z]")
    if [ -f "$tempdir/cert.0" ]; then
      osslsigncode verify -CAfile $tempdir/cert.0 -require-leaf-hash sha256:$hash $file 2>&1 > /dev/null || return 3
    else
      osslsigncode verify -require-leaf-hash sha256:$hash $file 2>&1 > /dev/null || return 3
    fi
  done
  return 0
}

verifgpg(){
  local id=$1
  local tempdir=$2
  local file=$3
  if [ "${file##.*}" == "gpg" ]; then
    gpg --no-default-keyring --keyring $tempdir/cert.0.gpg --verify $file
  else
    gpg --no-default-keyring --keyring $tempdir/cert.0.gpg --verify $file.sig $file
  fi
  return $?
}

verifopenssl(){
  local id=$1
  local tempdir=$2
  local file=$3
  local args=""
  for _file in $(ls $tempdir); do
    [ "$(basename $_file)" == "cert.0" ] && continue
    args="$args $tempdir/$_file"
  done
  [ -n "$args" ] && args="-untrusted $args"
  [ -f "$tempdir/cert.0" ] && args="-CAfile $tempdir/cert.0 $args"
  openssl dgst -verify -keyform PEM -sha256 -signature $file.sig -binary $file $args
  return $?
}

verifliveupdate(){
  local id=$1
  local tempdir=$2
  local src=$3
  local file=$4
  local zipdir=$5
  local dest=$6
  local livetri=$7
  local sig grd args s1 s256 f basedir s t last filedir

  unzip -d $zipdir $src/$file >& /dev/null || 7z -o$zipdir x $src/$file >& /dev/null 
  sig=$(find $zipdir -name "*.sig")
  grd=$(find $zipdir -name "*.grd")

  [ -n "$grd" ] || { 1>&2 myecho "File *.grd not found in the archive $(basename $file)"; return 1; }
  [ -n "$sig" ] || { 1>&2 myecho "File *.sig not found in the archive $(basename $file)"; return 1; }

  # Assumes all of the CA are in $termpdir/cert.0 and the other certificates in $tempdir/cert.1
  args="-purpose any -no_check_time"
  [ -f "$tempdir/cert.0" ] && args="$args -CAfile $tempdir/cert.0"
  [ -f "$tempdir/ceirt.1" ] && args="$args -nointern -certfile $tempdir/cert.1"
    
  # Verify the signature of the  file *.grd...  
  for s in $sig; do
    # Special case v1.sig that is an alternative signature for v.sig
    [ "$(basename $s)" == "v1.sig" ] && continue
    t=$(echo $s | sed -e 's/.sig$/.grd/g')
    echo $grd | grep -q $t || { 2>&1 myecho "Checksum file $t not found in the archive $(basename $file)"; return 1; }
    openssl cms -verify -inform DER -in $s -content $t $args > /dev/null 2>&1 || \
        { 1>&2 myecho "Verification failure of the file $t from the archive $(basename $file) "; return 1; }
  done

  # Get base directory name
  basedir=$(dirname $(find $zipdir -name "*.grd" | head -n1))

  # Fail if there are any files in the archive not listed in the file GRD
  for f in $(cd $basedir/; find . -type f | cut -c3-); do
    [[ "$f" =~ ".*.grd" ]] && continue
    [[ "$f" =~ ".*.sig" ]] && continue
    if ! grep -qi $f $grd; then
      # FIXME The JDB files have the files lic.dat and navlic.dat that are not listed 
      # in a grd file; What are these files ? How to check them ? For now we ignore
      # these files under three conditions:
      #    1. The file size is exactly 1048 bytes
      #    2. navlic.dat et lic.dat are the same file
      #    3. They are both listed in the catalog.dat file that is included in v.grd
      if [ "$f" == "lic.dat" ] || [ "$f" == "navlic.dat" ]; then
        [ "$(stat -c%s $basedir/$f)" == "1048" ] || { 1>&2 myecho "Can not verify the file $f from the archive $(basename $file)"; return 1; }
        [ -f "$basedir/lic.dat" ] && [ -f "$basedir/navlic.dat" ] && diff -q $zipdir/lic.dat $zipdir/navlic.dat || { 1>&2 myecho "Can not verify the file $f from the archive $(basename $file)"; return 1; }
        grep -qi $f $basedir/catalog.dat || { 1>&2 myecho "Can not verify the file $f from the archive $(basename $file)"; return 1; }       
      else
        1>&2 myecho "Can not verify the file $f from the archive $(basename $file)"; 
        return 1;
      fi
    fi
  done

  s1=""
  s256=""
  f=""
  last=""
  filedir=$(dirname $file)
  for t in $grd; do
    while :; do
      IFS= read -r line || last="true"
      if [ -n "$last" ] || [[ "$line" =~ "^\[File-.*\]" ]]; then
        [ -z "$last" ] && [ -z "$f" ] && { f=$(echo $line | sed -e "s/^\[File-\(.*\)\]\s*$/\1/g"); continue; }
        if [ -f "$basedir/$f" ]; then
          [ -z "$s256" ] || sha256sum $basedir/$f | grep -q $s256 || \
              { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename $file)"; return 2; }
          [ -z "$s1" ] || sha1sum $basedir/$f | grep -q $s1 || \
              { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename $file)"; return 2; }
          [ -z "$256" ] && [ -z "$s1" ] && { 1>&2 myecho "File $f from the archive $(basename $file) has no checksum"; return 2; }
          1>&2 myecho "File $f from the archive $(basename $file) verified"
        elif [ -f "$src/$filedir/$f" ]; then
          # Only reverify the hash if its not already done.
          if [ ! $src/$filedir/$f -ef $dest/$filedir/$f ]; then
            [ -z "$s256" ] || sha256sum $src/$filedir/$f | grep -q $s256 || \
                { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename $file)"; return 2; }
            [ -z "$s1" ] || sha1sum $src/$filedir/$f | grep -q $s1 || \
                { 1>&2 myecho "Verification of checksum failed for $f from the archive $(basename $file)"; return 2; }
            [ -z "$256" ] && [ -z "$s1" ] && { 1>&2 myecho "File $f from the archive $(basename $file) has no checksum"; return 2; }
            if [ -n "$livetri" ]; then
              msgline $src/$filedir/$f 0
              ln $src/$filedir/$f $dest/$filedir/$f
            fi
            1>&2 myecho "File $f verified"
          fi
        else
          1>&2 echo "File $f not found. skipping"
        fi
        [ -z "$last" ] || break;
        f=$(echo $line | sed -e "s/^\[File-\(.*\)\]\s*$/\1/g")
        [ -f "$basedir/$f" ] || [ -f "$src/$filedir/$f" ] || f=$(echo $f | awk '{print tolower($0)}')
        s1=""
        s256=""
      elif [[ "$line" =~ "^SHA1=.*" ]]; then
        s1=$(echo $line | sed -e "s/^SHA1=\([0-9a-fA-F]*\)\s*$/\1/g")
      elif [[ "$line" =~ "^SHA256=.*" ]]; then
        s256=$(echo $line | sed -e "s/^SHA256=\([0-9a-fA-F]*\)\s*$/\1/g")
      fi
    done < $t
  done

  1>&2 myecho "Archive $(basename $file) correctly verified"
  return 0
}

verifdirectory() {
  local filetable file status i j fprint tempdir idx auth
  local id=$1
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)
  local type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" $CONF)

  # Validate check type
  case $type in
    authenticode|openssl|gpg|liveupdate) : ;;
    *) 1>&2 echo "Unknown file checking type"; exit 1 ;;
  esac

  tempdir=$(mktemp -d)
  i=1
  j=1
  while :; do
    fprint=$(xmllint --xpath "string(dsas/tasks/task[$id]/cert[$j]/fingerprint)" $CONF)
    [ -z "$fprint" ] && break;
    idx=$(get_certificate $fprint)
    [ -z "$idx" ] && { 1>&2 echo "Certificate used by task($id) not found !!"; cleanup_and_exit 1 $tempdir; }
    if [ $idx -eq 0 ]; then
      if [ "$type" == "liveupdate" ]; then
        cat /tmp/cert.$$ >> $tempdir/cert.0
      else
        [ -f "$tempdir/cert.0" ] && myecho "Multiple authority certificates defined" 
        /bin/mv /tmp/cert.$$ $tempdir/cert.0
      fi
    else
      auth=$(xmllint --xpath "string(dsas/certificates/certificate[$idx]/authority)" $CONF)
      if [ "$auth" == "true" ]; then
        if [ "$type" == "liveupdate" ]; then
          cat /tmp/cert.$$ >> $tempdir/cert.0
        else
          [ -f "$tempdir/cert.0" ] && myecho "Multiple authority certificates defined"
          /bin/mv /tmp/cert.$$ $tempdir/cert.0
        fi
      else
        if [ "$type" == "liveupdate" ]; then
          cat /tmp/cert.$$ >> $tempdir/cert.1
        else
          /bin/mv -f /tmp/cert.$$ $tempdir/cert.$((i++))
        fi
      fi
    fi
    j=$((j + 1))
  done
  if [ "$type" == "gpg" ]; then
    # Need to dearmor gpg certificate before use
    gpg --dearmor $tempdir/cert.0
  fi

  # Create directory if needed
  [ -d $DSAS_BAS/$dir ] || $(umask 007 && mkdir -p $DSAS_BAS/$dir && chgrp $grp $DSAS_BAS/$dir )

  # Remove the files in our tree bas and not in haut.
  filetable=$(ls -1 $DSAS_HAUT/$dir)
  for file in $(cd $DSAS_BAS/$dir; find . -type f); do
    if [[ "$filetable" != *"${file:2}"* ]]; then
      myecho "Removing stale file ${file:2}"
      /bin/rm -f $DSAS_BAS/$dir/${file:2}
    fi
  done

  # If LiveUpdate, test files *livetri.zip first as they can sign other files
  if [ "$type" == "liveupdate" ]; then
    for file in $(cd $DSAS_HAUT; find $dir -type f -name "*livetri.zip" -o -name "minitri.flg" \
        -o -name "SymantecProductCatalog.zip"); do
      # If file exists in bas skip. Hardlinked, so test is fast
      [ $DSAS_HAUT/$file -ef $DSAS_BAS/$file ] && continue

      zipdir=$(mktemp -d)
      if [[ "$file" == "*livetri.zip" ]]; then
        verifliveupdate $id "$tempdir" "$DSAS_HAUT" "$file" "$zipdir" "$DSAS_BAS" "true"
      elif [ "$file" == "minitri.flg" ]; then
        # mintri.flg is one byte with a single 0x20 character
        [ "$(cat $DSAS_HAUT/$file)" == " " ]
      else
        verifliveupdate $id "$tempdir" "$DSAS_HAUT" "$file" "$zipdir" "$DSAS_BAS"
      fi
      status=$?
      msgline $DSAS_HAUT/$file $status
      [ $status -eq 0 ] && ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
      /bin/rm -fr $zipdir
    done 
  else
    for file in $(cd $DSAS_HAUT; find $dir -type f); do
      # If file exists in bas skip. Hardlinked, so test is fast
      [ $DSAS_HAUT/$file -ef $DSAS_BAS/$file ] && continue

      case $type in
        authenticode) verifauthenticode $id "$tempdir" "$DSAS_HAUT/$file" ;;
        openssl) 
          [ "${file##.*}" == "asc" ]  && continue 
          verifopenssl $id "$tempdir" "$DSAS_HAUT/$file"
          ;;
        gpg)
          [ "${file##.*}" == "sig" ]  && continue 
          verifgpg $id "$tempdir" "$DSAS_HAUT/$file"
          ;;
      esac
      status=$?
      msgline $DSAS_HAUT/$file $status
      if [ $status -eq 0 ]; then
        ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
        [ "$type" == "gpg" ] && [ "${file##.*}" != "gpg" ] && ln "$DSAS_HAUT/$file.sig" "$DSAS_BAS/$file.sig"
        [ "$type" == "openssl" ] && ln "$DSAS_HAUT/$file.asc" "$DSAS_BAS/$file.asc"
      fi
    done
  fi
  /bin/rm -fr $tempdir
}

verify_packages() {
  local file chktype chksum
  local dir=$1
  local rpm_k=$2
  shift 2
  while [ "$#" -gt 2 ]; do
    if [ ${1: -3} == "rpm" ]; then
      file=$1
      chktype=$2
      chksum=$3
    else
     file=$3
     chktype=$1
     chksum=$2
    fi
    shift 3

    # If file exists in bas skip. Hardlinked, so test is fast
    [ $DSAS_HAUT/$dir/$file -ef $DSAS_BAS/$dir/$file ] && continue

    if [ -f "$DSAS_HAUT/$dir/$file" ]; then
      if  check_checksum $DSAS_HAUT/$dir/$file $chksum $chktype; then
        msgline $DSAS_HAUT/$dir/$file 1
      elif [ "$rpm_k" == "1" ] && ! rpm -K $DSAS_HAUT/$dir/$file 2>&1 1> /dev/null; then
        msgline $DSAS_HAUT/$dir/$file 5      
      else
        msgline $DSAS_HAUT/$dir/$file 0
        ln $DSAS_HAUT/$dir/$file $DSAS_BAS/$dir/$file
      fi
    fi  # For now ignore missing files
  done
}

verifrepo() {
  local tempdir fprint idx filelist chksum chktype unzipfile filetable
  local id=$1
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)
  local type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" $CONF)

  tempdir=$(mktemp -d)
  fprint=$(xmllint --xpath "string(dsas/tasks/task[$id]/cert[1]/fingerprint)" $CONF)
  idx=$(get_certificate $fprint)
  [ -z "$idx" ] && { 1>&2 echo "Certificate used by task\($id\) not found !!"; exit 1; }
  /bin/mv /tmp/cert.$$ $tempdir/cert.0
  gpg --dearmor $tempdir/cert.0

  if [ "$type" == "repomd" ]; then
    # Verify the repomd.xml against the GPG signature repomd.xml.asc
    # FIXME Why does this still print something !!
    if ! gpg --no-default-keyring --keyring $tempdir/cert.0.gpg  \
          --verify $DSAS_HAUT/$dir/repodata/repomd.xml.asc \
          $DSAS_HAUT/$dir/repodata/repomd.xml 2>&1 1> /dev/null; then
      1>&2 echo "Failed to verify repomd.xml signature"
      exit 1
    fi
  else
    # For rpm signature verification need to import GPG key
    rpm --import $tempdir/cert.0 2>&1 1> /dev/null
  fi 

  # Create the destination directory if needed
  [ -d $DSAS_BAS/$dir ] || $(umask 007 && mkdir -p $DSAS_BAS/$dir && chgrp $grp $DSAS_BAS/$dir)

  # Copy repomd.xml* to $bas
  ln $DSAS_HAUT/$dir/repodata/repomd.xml $DSAS_BAS/$dir/repodata/repomd.xml
  [ -f "$DSAS_HAUT/$dir/repodata/repomd.xml.asc" ] && ln $DSAS_HAUT/$dir/repodata/repomd.xml.asc $DSAS_BAS/$dir/repodata/repomd.xml.asc

  # Verify the checksum of all files referenced in repomd.xml and copy tp $bas
  i=1
  while :; do
    # Note that we have to ignore the xml namespace (initial cat/sed)
    f=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[$i]/location/@href)' -)
    [ -z "$f" ] && break

    # Verify its checksum
    chksum=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[$i]/checksum)' - )
    chktype=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[$i]/checksum/@type)' - )
    if  check_checksum $DSAS_HAUT/$dir/$f $chksum $chktype; then
      1>&2 echo "Error verifiying checksum of $f"
      cleanup_and_exit 1 $tempdir
    fi
    ln $DSAS_HAUT/$dir/$f $DSAS_BAS/$dir/$f
    i=$(($i + 1))
  done

  # Identify the primary file list
  # Note that we have to ignore the xml namespace (initial cat/sed)
  filelist=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[@type="primary"]/location/@href)' -)

  # Recover a table of the hashtype, hash and file names
  if [[ "$f" =~ ".*.gz" ]] || [[ "$f" =~ ".*.bz2" ]]; then
    filetable=$(zcat $DSAS_HAUT/$dir/$unzipfile | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
  else
    filetable=$(cat $DSAS_HAUT/$dir/$unzipfile | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
  fi

  # Remove the files in $DSAS_BAS and not listed in primary.xml
  for _file in $(cd $DSAS_BAS/$dir; find . -path ./repodata -prune -type f -o -type f); do
    if [[ "$filetable" != *"${_file:2}"* ]]; then
      myecho "Removing stale file ${_file:2}"
      /bin/rm -f $DSAS_BAS/$dir/${_file:2}
    fi
  done

  # Verify the packages
  [ "$type" == "rpm" ] && verify_packages $dir 1 $filetable
  [ "$type" == "rpm" ] || verify_packages $dir 0 $filetable
  
  # Remove all RPM signature keys    
  [ "$type" == "rpm" ] && rpm -e $(rpm -qa)

  /bin/rm -fr $tempdir
}

passdirectory(){
  local filetable file status i j fprint tempdir idx auth
  local id=$1
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)

  # Create directory if needed
  [ -d $DSAS_BAS/$dir ] ||  $(umask 007 && mkdir -p $DSAS_BAS/$dir && chgrp $grp $DSAS_BAS/$dir)

  # Remove the files in our tree bas and not in haut.
  filetable=$(ls -1 $DSAS_HAUT/$dir)
  for file in $(cd $DSAS_BAS/$dir; find . -type f); do
    if [[ "$filetable" != *"${file:2}"* ]]; then
      myecho "Removing stale file ${file:2}"
      /bin/rm -f $DSAS_BAS/$dir/${file:2}
    fi
  done

  for file in $(cd $DSAS_HAUT; find $dir -type f); do
    # If file exists in bas skip. Hardlinked, so test is fast
    [ $DSAS_HAUT/$file -ef $DSAS_BAS/$file ] && continue

    # Don't log the transfers with msgline for the mache haut as
    # the logs aren't yet used
    ln "$DSAS_HAUT/$file" "$DSAS_BAS/$file"
  done
}

check_dsas

# Parse options
ids=""
while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose) verbose=1 ;;
    -q|--quiet) verbose=0 ;;
    -r[--rotate) rotate=1 ;;
    -n|--dryrun) dryrun=1 ;;
    -s|--stdout) logstdout=1 ;;
    -l|--log) logstdout=0 ;;
    -o) logfile=$2; shift 1 ;;
    --out=*) logfile=${1#*=} ;;
    -?|-h|--help) help; exit 0 ;;
    -*) 1>&2 echo "Unrecognized option : $1"; help; exit 1 ;;
    *) 
      [ -n "$ids" ] && { 1>&2 echo "Only a single task is allowed"; exit 1; }
      ids="$ids $1" 
      ;;
  esac
  shift 1
done

# If dryrun, force verbose
[ $dryrun -ne 0 ] && verbose=1

# Check that all ids are valid before doing anything
idx=""
for _id in $ids; do
  _idx=$(task_id_to_idx $_id)
  [ $? -ne 0 ] && { 1>&2 echo "Task id\($_id\) does not exist"; exit 1; }
  idx="$idx $_idx"
done

for _id in $idx; do
  if [ "$TYP" == "haut" ]; then
    # No verification on the machine haut
    passdirectory $_id
  else
    type=$(xmllint --xpath "string(dsas/tasks/task[$_id]/type)" $CONF)
    case $type in
      rpm|repomd) verifrepo $_id; ;;
      deb) 1>&2 echo "DEB files are  are not yet implemented"; exit 1; ;;
      authenticode|openssl|gpg|liveupdate) verifdirectory $_id; ;; 
      *) 1>&2 echo "Unknown task type : $type"; exit 1 ;;
    esac
  fi
done
