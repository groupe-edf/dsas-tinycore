#! /bin/sh

if [ -f "$(dirname $0)/dsas_common.sh" ]; then
  . $(dirname $0)/dsas_common.sh
else
  1>&2 echo "Common functions not found !!"
  exit -1
fi

getdirectory() {
  local status dirlist files file
  local id=$1
  local uri=$(get_uri $id)
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)
  local name=$(xmllint --xpath "string(dsas/tasks/task[$id]/name)" $CONF)

  if [ -z "$uri" ]; then
    # The URI can be empty. gracefully exit
    myecho "Empty Uri for task $name"
    return
  fi

  # Create directory if needed
  [ -d ${DSAS_HAUT}/$dir ] || $(umask 007 && mkdir -p ${DSAS_HAUT}/$dir)

  # If no trailing "/" or "\" assume we have a file and not a directory
  # Special case for scp, because it can only have one file
  status=1
  if [ "${uri:0:4}" == "scp:" ] || ([ "${uri: -1}" != "/" ] &&  [ "${uri: -1}" == "\\" ]); then
    myecho "Downloading file: $(basename $uri)"
    get "${uri}" "${DSAS_HAUT}/${dir}/${basename $uri}"
    status=$?
  fi

  # If uri ends in "/" or the fetch of a file above fails, its probably Ã  directory
  if [ "${uri:0:4}" != "scp:" ] && [ "$status" -ne "0" ]; then
    myecho "Downloading directory listing : $uri"
    files=$(get_dirlist $uri) || { 1>&2 echo "error fetching directory listing"; exit 1; }

    # Remove files locally that are no longer available sur le URI
    for file in $(ls -1 $DSAS_HAUT/$dir); do
      # Ignore directories for now
      [ "${file: -1}" == "/" ] && continue
      
      if [[ "$files" != *"$file"* ]]; then
        myecho "Removing stale file: $file"
        /bin/rm -f $DSAS_HAUT/$dir/$file
      fi
    done

    # Download the missing files
    for file in $files; do
      # Ignore directories for now
      [ "${file: -1}" == "/" ] && continue
      if [ ! -f "$DSAS_HAUT/$dir/$file" ]; then
        myecho "Downloading file: $file"
        get "${uri}${file}" "${DSAS_HAUT}/${dir}/${file}"
      fi
    done
  fi
}

get_packages() {
  local file chktype chksum
  local dest=$1
  local uri=$2
  shift 2
  while [ "$#" -gt 2 ]; do
    if [ ${1: -3} == "rpm" ]; then
      file=$1
      chktype=$2
      chksum=$3
    else
     file=$3
     chktype=$1
     chksum=$2
    fi
    if [ -f "$dest/$file" ]; then
      if check_checksum $dest/$file $chksum $chktype; then
        # Checksum of file is different redownload the file
        myecho "Downloading file $file [Checksum different!!]"
        [ -d "$(dirname $dest/$file)" ] || $(umask 007 && mkdir -p $(dirname $dest/$file))
        get $uri/$file $dest/$file
      else
        myecho "Skipping file $file"
      fi
    else
      myecho "Downloading file $file"
      [ -d "$(dirname $dest/$file)" ] || $(umask 007 && mkdir -p $(dirname $dest/$file))
      get $uri/$file $dest/$file
    fi
    shift 3
  done
}

getrepo() {
  local i filelist chksum chktype filetable _file
  local id=$1
  local uri=$(get_uri $id)
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)
  local name=$(xmllint --xpath "string(dsas/tasks/task[$id]/name)" $CONF)
  local type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" $CONF)

  case $type in
    repomd|rpm)
       # Create the destination directory if needed
       [ -d "$DSAS_HAUT/$dir" ] || $(umask 007 && mkdir -p $DSAS_HAUT/$dir)

       myecho "Downloading repodata/repomd.xml from $name"
       [ -d $DSAS_HAUT/$dir/repodata ] || $(umask 007 && mkdir -p $DSAS_HAUT/$dir/repodata)

       get -force "$uri/repodata/repomd.xml" "$DSAS_HAUT/$dir/repodata/repomd.xml" 
       [ "$type" == "rpm" ] || get -force "$uri/repodata/repomd.xml.asc" "$DSAS_HAUT/$dir/repodata/repomd.xml.asc" 

       # Identify all files listed in repomd.xml and download them
       i=1
       while :; do
         # Note that we have to ignore the xml namespace (initial cat/sed)
         f=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath 'string(//repomd/data[$i]/location/@href)' -)
         [ -z "$f" ] && break
         myecho "Downloading file $f listed in repomd.xml for $name"
         get -force "$uri/$f" "$DSAS_HAUT/$dir/$f"

         # Verify its checksum
         chksum=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath 'string(//repomd/data[$i]/checksum)' - )
         chktype=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath 'string(//repomd/data[$i]/checksum/@type)' - )
         if  check_checksum $DSAS_HAUT/$dir/$f $chksum $chktype; then
             1>&2 echo "Error verifiying checksum of $f"
           cleanup_and_exit 1 $tempdir
         fi
         i=$(($i + 1))
       done

       # Identify the primary file list and download it
       # Note that we have to ignore the xml namespace (initial cat/sed)
       filelist=$(cat $DSAS_HAUT/$dir/repodata/repomd.xml | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[@type="primary"]/location/@href)' - )

       # Recover a table of the hashtype, hash and file names
       if [[ "$f" =~ ".*.gz" ]] || [[ "$f" =~ ".*.bz2" ]]; then
         filetable=$(zcat $DSAS_HAUT/$dir/$filelist | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
       else
         filetable=$(cat $DSAS_HAUT/$dir/$filelist | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
       fi

       # Remove the files in our tree not listed in primary.xml
       for _file in $(cd $DSAS_HAUT/$dir; find . -path ./repodata -prune -type f -o -type f); do
         if [[ "$filetable" != *"${_file:2}"* ]]; then
           myecho "Removing stale file ${_file:2}"
           /bin/rm -f $DSAS_HAUT/$dir/${_file:2}
         fi
       done

       # Download the packages
       get_packages "$DSAS_HAUT/$dir" $uri $filetable
       ;;
    *) 1>&2 echo "Unrecognized repositiory check type $check"; exit 1; ;;
  esac
}

help() {
  echo "Usage: $(basename $0)  [Options] ID"
  echo "Get files given by the task ID"
  echo "     -v|--verbose    Log all files verified"
  echo "     -q|--quiet      Log only files failing to verifiy"
  echo "     -n|--dryrun     Perform no actions"
  echo "     -?|-h|--help    Print this help"
}

check_dsas

# Parse options
ids=""
while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose) verbose=1 ;;
    -q|--quiet) verbose=0 ;;
    -n|--dryrun) dryrun=1 ;;
    -?|-h|--help) help; exit 0 ;;
    -*) 1>&2 echo "Unrecognized option : $1"; help; exit 1 ;;
     *)
       # Only allow a single task to be able to exit en error correctly 
       [ -n "$ids" ] && { 1>&2 ecdo "Only a single task is allowed"; exit 1; }
       ids="$ids $1" ;;
  esac
  shift 1
done

# If dryrun, force verbose
[ $dryrun -ne 0 ] && verbose=1

# Check that all ids are valid before doing anything
idx=""
for _id in $ids; do
  _idx=$(task_id_to_idx $_id)
  [ $? -ne 0 ] && { 1>&2 echo "Task id ($_id) does not exist"; exit 1; }
  idx="$idx $_idx"
done

for _idx in $idx; do
  type=$(xmllint --xpath "string(dsas/tasks/task[$_idx]/type)" $CONF)
  case $type in
    rpm|repomd) getrepo $_idx; ;;
    deb) 1>&2 echo "DEB files are not yet implemented"; exit 1; ;;
    authenticode|openssl|gpg|liveupdate) getdirectory $_idx; ;;
    *) 1>&2 echo "Unknown task type : $type"; exit 1; ;;
  esac
done

