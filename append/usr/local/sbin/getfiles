#! /bin/sh

if [ -f "$(dirname $0)/dsas_common.sh" ]; then
  . $(dirname $0)/dsas_common.sh
else
  1>&2 echo "Common functions not found !!"
  exit -1
fi

lftp_ca_options() {
  local id=$1
  local opt=""

  if [ "$TYP" == "haut" ]; then
    # Setup the LFTP CA if needed. If ClamAv force self_sugned for now
    # ClamAV signatures are verified elsewhere before use
    [ "$clamav" == "1" ] && ca_finger="self"
    [ "$clamav" == "1" ] || ca_finger=$(xmllint --xpath "string(dsas/tasks/task[$id]/ca/fingerprint)" $CONF)

    case $ca_finger in
      "")  opt="set net:timeout 3; set net:max-retries 3; " ;;
      "self") opt="set net:timeout 3; set net:max-retries 3; set ssl:verify-certificate false; " ;;
      *)
        idx=$(get_certificate $ca_finger)
        [ -z "$idx" ] || opt="set net:timeout 3; set net:max-retries 3; set ssl:ca-file /tmp/cert.$$; "
        [ -z "$idx" ] && opt="set net:timeout 3; set net:max-retries 3; "
        ;;
    esac
  fi
  echo $opt
}

getclamav() {
  local uri
  local dir="ClamAV"
  local name="ClamAV"
  local opt=$(lftp_ca_options)

  # Return if antivirus is not active
  [ "$(xmllint --xpath "string(dsas/config/antivirus/active)" "$CONF")" == "true" ] || return

  if [ "$TYP" == "haut" ]; then
    uri=$(xmllint --xpath "string(dsas/config/antivirus/uri)" "$CONF") 
  else
    local _uri="$DSAS_HOME/bas"
    _uri=${DSAS_BAS:${#_uri}}
    uri="sftp://bas:@$INTERCO_HAUT$_uri/$dir/"
  fi
  if [ -z "$uri" ]; then
    # The URI can be empty. gracefully exit
    myecho "Empty uri for task $name"
    return
  fi

  # Create directory if needed
  [ -d "${DSAS_HAUT}/$dir" ] || $(umask 007 && mkdir -p "${DSAS_HAUT}/$dir")

  # Download the CVD files. Can't mirror as can't do ls on directory database.clamav.net 
  for _file in main.cvd daily.cvd bytecode.cvd; do
    [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'" >& /dev/null
    [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'"
  done

  # Correct directory permissions
  find "$DSAS_HAUT/$dir" -type d -exec chmod 770 {} \;

  [ -f "/tmp/cert.$$" ] && rm /tmp/cert.$$

  exit 0
}

getdirectory() {
  local isdir
  local id=$1
  local uri=$(get_uri $id)
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  local name=$(xmllint --xpath "string(dsas/tasks/task[$id]/name)" "$CONF")
  local opt=$(lftp_ca_options $id)

  if [ -z "$uri" ]; then
    # The URI can be empty. gracefully exit
    myecho "Empty uri for task $name"
    return
  fi

  # Create directory if needed
  [ -d "${DSAS_HAUT}/$dir" ] || $(umask 007 && mkdir -p "${DSAS_HAUT}/$dir")

  # Test whether we have a file or a directory
  isdir=""
  [ "${uri: -1}" == "/" ] && isdir="1"
  [ "${uri: -1}" == "\\" ] && isdir="1"
  [ -z "$isdir" ] && _stderr=$(2>&1 lftp -c "$opt open '$uri'") && isdir="1"
  echo $_stderr | grep -q "Fatal" && (1>&2 echo "Fatal: Server not found"; exit 1)

  if [ -z "$isdir" ]; then
    myecho "Downloading file : $(basename "$uri")"
    # FIXME shouldn't always download here !!!
    [ "$verbose" -eq 0 ] && lftp -c "$opt get -e -O '${DSAS_HAUT}/${dir}' '$uri'" >& /dev/null
    [ "$verbose" -eq 0 ] || lftp -c "$opt get -e -O '${DSAS_HAUT}/${dir}' '$uri'"
  else
    myecho "Mirroring site : $uri"
    [ "$verbose" -eq 0 ] && (cd "$DSAS_HAUT"; lftp -c "$opt open '$uri'; mirror --delete-first -e -O '$DSAS_HAUT/$dir'" >& /dev/null)
    [ "$verbose" -eq 0 ] || (cd "$DSAS_HAUT"; lftp -c "$opt open '$uri'; mirror --delete-first -e -O '$DSAS_HAUT/$dir'")

    # Correct directory permissions
    find "$DSAS_HAUT/$dir" -type d -exec chmod 770 {} \;
  fi

  [ -f "/tmp/cert.$$" ] && rm /tmp/cert.$$

  # There might be empty directories lying about. Remove them
  OLD_IFS=$IFS
  IFS=$'\3'
  for _dir in $(find "$DSAS_HAUT/$dir" -mindepth 1 -type d -exec echo -n -e "{}\x03" \; ); do
    [ "$(ls -A "$_dir")" ] || rmdir "$_dir"
  done
  IFS=$OLD_IFS

  exit 0
}

get_packages() {
  local file chktype chksum
  local dest="$1"
  local uri="$2"
  local opt="$3"
  shift 3
  while [ "$#" -gt 2 ]; do
    if [ "${1: -3}" == "rpm" ]; then
      file=$1
      chktype=$2
      chksum=$3
    else
     file=$3
     chktype=$1
     chksum=$2
    fi
    if [ -f "$dest/$file" ]; then
      if check_checksum "$dest/$file" $chksum $chktype; then
        # Checksum of file is different redownload the file
        myecho "Downloading file $file [Checksum different!!]"
        [ -d "$(dirname "$dest/$file")" ] || $(umask 007 && mkdir -p $(dirname "$dest/$file"))
        [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$file' -o '$dest/$file'" >& /dev/null
        [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$file' -o '$dest/$file'"
      else
        myecho "Skipping file $file"
      fi
    else
      myecho "Downloading file $file"
      [ -d "$(dirname "$dest/$file")" ] || $(umask 007 && mkdir -p $(dirname "$dest/$file"))
      [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$file' -o '$dest/$file'" >& /dev/null
      [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$file' -o '$dest/$file'"
    fi
    shift 3
  done
}

getrepo() {
  local i filelist chksum chktype filetable _file
  local id=$1
  local uri=$(get_uri $id)
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" "$CONF")
  local name=$(xmllint --xpath "string(dsas/tasks/task[$id]/name)" "$CONF")
  local type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" "$CONF")
  local opt=$(lftp_ca_options $id)

  case $type in
    repomd|rpm)
       # Create the destination directory if needed
       [ -d "$DSAS_HAUT/$dir" ] || $(umask 007 && mkdir -p "$DSAS_HAUT/$dir")

       myecho "Downloading repodata/repomd.xml from $name"
       [ -d "$DSAS_HAUT/$dir/repodata" ] || $(umask 007 && mkdir -p "$DSAS_HAUT/$dir/repodata")

       lftp -c "$opt get -e '$uri/repodata/repomd.xml' -o '$DSAS_HAUT/$dir/repodata/repomd.xml'" >& /dev/null
       [ "$type" == "rpm" ] || lftp -c "$opt get -e '$uri/repodata/repomd.xml.asc' -o '$DSAS_HAUT/$dir/repodata/repomd.xml.asc'" >& /dev/null

       # Identify all files listed in repomd.xml and download them
       i=1
       while :; do
         # Note that we have to ignore the xml namespace (initial cat/sed)
         f=$(cat "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath "string(//repomd/data[$i]/location/@href)" -)
         [ -z "$f" ] && break
         myecho "Downloading file $f listed in repomd.xml for $name"
         [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$f' -o '$DSAS_HAUT/$dir/$f'" >& /dev/null
         [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$f' -o '$DSAS_HAUT/$dir/$f'"

         # Verify its checksum
         chksum=$(cat "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath "string(//repomd/data[$i]/checksum)" - )
         chktype=$(cat "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
             sed -e "s:repomd xmlns:repomd ignore:g" | \
             xmllint --xpath "string(//repomd/data[$i]/checksum/@type)" - )
         if  check_checksum "$DSAS_HAUT/$dir/$f" $chksum $chktype; then
             1>&2 echo "Error verifiying checksum of $f"
           cleanup_and_exit 1 $tempdir
         fi
         i=$(($i + 1))
       done

       # Identify the primary file list and download it
       # Note that we have to ignore the xml namespace (initial cat/sed)
       filelist=$(cat "$DSAS_HAUT/$dir/repodata/repomd.xml" | \
         sed -e "s:repomd xmlns:repomd ignore:g" | \
         xmllint --xpath 'string(//repomd/data[@type="primary"]/location/@href)' - )

       # Recover a table of the hashtype, hash and file names
       if [[ "$filelist" =~ ".*.gz" ]] || [[ "$filelist" =~ ".*.bz2" ]]; then
         filetable=$(zcat "$DSAS_HAUT/$dir/$filelist" | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
       else
         filetable=$(cat "$DSAS_HAUT/$dir/$filelist" | \
            sed -e "s/xmlns=/ignore=/g" | \
            xmllint --xpath '//package[@type="rpm"]/location | //package[@type="rpm"]/checksum' - | \
            sed -e 's:.*href="\(.*\)"/>$:\1:g' \
              -e 's:.*type="\([^"]*\)"[^>]*>\([0-9a-fA-F]*\)</checksum>:\1 \2:g')
       fi

       # Remove the files in our tree not listed in primary.xml
       for _file in $(cd "$DSAS_HAUT/$dir"; find . -path ./repodata -prune -type f -o -type f); do
         if [[ "$filetable" != *"${_file:2}"* ]]; then
           myecho "Removing stale file ${_file:2}"
           rm -f "$DSAS_HAUT/$dir/${_file:2}"
         fi
       done

       # Download the packages
       get_packages "$DSAS_HAUT/$dir" "$uri" "$opt" $filetable
       ;;
    *) 1>&2 echo "Unrecognized repositiory check type $check"; exit 1; ;;
  esac

  [ -f "/tmp/cert.$$" ] && rm /tmp/cert.$$

  exit 0
}

getdeb() {
  local chktyp inhash hashtyp _hash _hash_md5 _hash_sha256 _size _file
  local pool pool_local have_pool packages inpackage
  local id=$1
  local uri=$(get_uri $id)
  local dir=$(xmllint --xpath "string(dsas/tasks/task[$id]/directory)" $CONF)
  local name=$(xmllint --xpath "string(dsas/tasks/task[$id]/name)" $CONF)
  local type=$(xmllint --xpath "string(dsas/tasks/task[$id]/type)" $CONF)
  local opt=$(lftp_ca_options $id)

  case $type in
    deb)
       # Create the destination directory if needed
       [ -d "$DSAS_HAUT/$dir" ] || $(umask 007 && mkdir -p $DSAS_HAUT/$dir)

       myecho "Downloading Release/Release.gpg from $name"
       if [ "$verbose" -eq 0 ]; then
         lftp -c "$opt get -e '$uri/Release' -o '$DSAS_HAUT/$dir/Release'" >& /dev/null
         lftp -c "$opt get -e '$uri/Release.gpg' -o '$DSAS_HAUT/$dir/Release.gpg'" >& /dev/null
         lftp -c "$opt get -e '$uri/InRelease' -o '$DSAS_HAUT/$dir/InRelease'" >& /dev/null
       else
         lftp -c "$opt get -e '$uri/Release' -o '$DSAS_HAUT/$dir/Release'"
         lftp -c "$opt get -e '$uri/Release.gpg' -o '$DSAS_HAUT/$dir/Release.gpg'"
         lftp -c "$opt get -e '$uri/InRelease' -o '$DSAS_HAUT/$dir/InRelease'"
       fi

       [ -f "$DSAS_HAUT/$dir/Release" ] || $(1>&2 echo "Failed to download 'Release'"; exit 1)
       [ -f "$DSAS_HAUT/$dir/Release.gpg" ] || $(1>&2 echo "Failed to download 'Release.gpg'"; exit 1)

       # Find the pool directory
       pool=$(dirname "$uri")
       pool_local=$(dirname "$dir")
       have_pool="0"
       while [ -n "$pool" ] && [ "${pool: -3}" != "://" ]; do
         $(lftp -c "$opt open '$pool/pool'" >& /dev/null) && have_pool="1" && break
         pool=$(dirname "$pool")
         pool_local=$(dirname "$pool_local")
       done
       [ "$have_pool" == "0" ] && $(1>&2 echo "Debian pool directory not found"; exit 1)


       # Identify if the Release file has SHA256 et/ou MD5 hashes
       grep -qx "MD5Sum:" "$DSAS_HAUT/$dir/Release" && hashtyp="MD5Sum:" && chktyp="md5"
       grep -qx "SHA1:" "$DSAS_HAUT/$dir/Release" && hashtyp="SHA1:" && chktyp="sha"
       grep -qx "SHA256:" "$DSAS_HAUT/$dir/Release" && hashtyp="SHA256:" && chktyp="sha256"

       # Identify all files listed in Release and download them
       inhash=0
       while read -r line; do
         # Assume that each hash is listed after the correct flag and has
         # a leading space
         [ "$inhash" == "0" ] && [[ "$line" =~ "^$hashtyp$" ]] && inhash="1" && continue
         [ "$inhash" == "1" ] && [[ "$line" =~ ":$" ]] && inhash="0" && continue
         [ "$inhash" == "0" ] && continue

         IFS=' ' read _hash _size _file << EOF
$line
EOF
         if [ -f "$DSAS_HAUT/$dir/$_file" ]; then
           if check_checksum "$DSAS_HAUT/$dir/$_file" $_hash $chktyp; then
             myecho "Downloading file $_file [Checksum different!!]"
             [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'" >& /dev/null
             [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'"
           else
             myecho "Skipping file $_file"
           fi
         else
           myecho "Downloading file $_file"
           [ -d "$(dirname "$DSAS_HAUT/$dir/$_file")" ] || $(umask 007; mkdir -p "$(dirname "$DSAS_HAUT/$dir/$_file")")
           [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'" >& /dev/null
           [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$uri/$_file' -o '$DSAS_HAUT/$dir/$_file'"
         fi
       done < $DSAS_HAUT/$dir/Release

       # For each file Packages.gz download the listed files into the pool directory
       for packages in $(find "$DSAS_HAUT/$dir" -name "Packages.gz"); do
         inpackage=0
         _file=""
         _hash_md5=""
         _hash_sha256=""
         zcat "$packages" | while read -r line; do
           # Use sed to strip leading and trailing space, as can't used xargs due to possible
           # illegal characters like single quotes in strings. 
           [[ "$line" =~ "Filename:" ]] && _file="$(echo $line | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
           [[ "$line" =~ "MD5sum:" ]] && _hash_md5="$(echo $line | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
           [[ "$line" =~ "SHA256:" ]] && _hash_sha256="$(echo $line | cut -d: -f2- | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" && continue
           if [ -z "$(echo $line | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')" ]; then
             if [ -f "$DSAS_HAUT/$pool_local/$_file" ]; then
               [ -n "$hash_md5" ] && check_checksum "$DSAS_HUAT/$pool_local/$_file" $_hash_md5 md5
               [ "$?" -eq 0 ] && [ -n "$hash_sha256"  ] && check_checksum "$DSAS_HUAT/$pool_local/$_file" $_hash_sha256 sha256
               
               if [ "$?" -eq 0 ]; then
                 myecho "Downloading file $_file [Checksum different!!]"
                 [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$pool/$_file' -o '$DSAS_HAUT/$pool_local/$_file'" >& /dev/null
                 [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$pool/$_file' -o '$DSAS_HAUT/$pool_local/$_file'"
               else
                 myecho "Skipping file $_file"
               fi
             elif [ -n "$_file" ]; then
               myecho "Downloading file $_file"
               [ -d "$(dirname "$DSAS_HAUT/$pool_local/$_file")" ] || $(umask 007 && mkdir -p "$(dirname "$DSAS_HAUT/$pool_local/$_file")")
               [ "$verbose" -eq 0 ] && lftp -c "$opt get -e '$pool/$_file' -o '$DSAS_HAUT/$pool_local/$_file'" >& /dev/null
               [ "$verbose" -eq 0 ] || lftp -c "$opt get -e '$pool/$_file' -o '$DSAS_HAUT/$pool_local/$_file'"
             fi
             _file=""
             _hash_md5=""
             _hash_sha256=""
           fi
         done
       done

       ;;

     *) 1>&2 echo "Unknown file checking type"; exit 1; ;;
  esac

  exit 0
}


help() {
  echo "Usage: $(basename $0)  [Options] ID"
  echo "Get files given by the task ID"
  echo "     -v|--verbose    Log all files verified"
  echo "     -q|--quiet      Log only files failing to verifiy"
  echo "     -n|--dryrun     Perform no actions"
  echo "     -c|--clamav     Get ClamAv signature files"
  echo "     -?|-h|--help    Print this help"
}

check_dsas
clamav=0

# Parse options
ids=""
while [ "$#" -gt 0 ]; do
  case $1 in
    -v|--verbose) verbose=1 ;;
    -q|--quiet) verbose=0 ;;
    -n|--dryrun) dryrun=1 ;;
    -c|--clamav) clamav=1 ;;
    -?|-h|--help) help; exit 0 ;;
    -*) 1>&2 echo "Unrecognized option : $1"; help; exit 1 ;;
     *)
       # Only allow a single task to be able to exit en error correctly 
       [ -n "$ids" ] && { 1>&2 echo "Only a single task is allowed"; exit 1; }
       ids="$ids $1" ;;
  esac
  shift 1
done
 
# Change to a directory where the user 'haut' has write permissions
cd $DSAS_HAUT

# If dryrun, force verbose
[ $dryrun -ne 0 ] && verbose=1

# If ClamAV download request do it now and exit
[ "$clamav" == "1" ] && (getclamav; exit 0)

# Check that all ids are valid before doing anything
idx=""
for _id in $ids; do
  _idx=$(task_id_to_idx $_id)
  [ $? -ne 0 ] && { 1>&2 echo "Task id ($_id) does not exist"; exit 1; }
  idx="$idx $_idx"
done

for _idx in $idx; do
  type=$(xmllint --xpath "string(dsas/tasks/task[$_idx]/type)" $CONF)
  case $type in
    rpm|repomd) getrepo $_idx; ;;
    deb) getdeb $_idx; ;;
    authenticode|openssl|gpg|liveupdate|cyberwatch) getdirectory $_idx; ;;
    *) 1>&2 echo "Unknown task type : $type"; exit 1; ;;
  esac
done

