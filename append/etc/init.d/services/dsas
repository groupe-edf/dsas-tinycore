#!/bin/sh
#    DSAS - Tinycore
#    Copyright (C) 2021-2022  Electricite de France
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Shellcheck configuration to test for POSIX shell plus the Busybox/ASH extensions I use
# shellcheck shell=sh
# Allow process subsitution with "<()"
# shellcheck disable=SC3001
# Allow "[["
# shellcheck disable=SC3010
# Allow variable icrement
# shellcheck disable=SC3018
# Allow echo flags
# shellcheck disable=SC3037
# Allow "read -d"
# shellcheck disable=SC3045
# Allow string indexing like "${1:3}"
# shellcheck disable=SC3057
# Allow string replacement like "${1// }
# shellcheck disable=SC3060

RED="$(echo -e '\033[1;31m')"
GREEN="$(echo -e '\033[1;32m')"
YELLOW="$(echo -e '\033[1;33m')"
NORMAL="$(echo -e '\033[1;39m')"
MNT=/mnt

# The version of the DSAS xml file supported by this version
DSAS_XML_VERSION="0.15"

VAR=/var/dsas
RADIUS_SERVER="/etc/raddb/server"

as_tc="sudo -E -u tc"
as_haut="sudo -E -u haut"

# In an unprivelged docker, /dev is not available, and so 'fdisk -l' returns nothing
[ -z "$(fdisk -l)" ] && ISDOCKER=1

mounted(){
  grep "$1" /etc/mtab > /dev/null 2>&1 && return 0
  return 1
}

mount_dsas(){
  if [ -z "$ISDOCKER" ]; then
    if [ ! "$(mounted /home/dsas)" ]; then
      echo "Mounting ${GREEN}$DSAS${NORMAL} on ${GREEN}/home/dsas${NORMAL}"
      mkdir -p /home/dsas
      chown root.staff /home/dsas
      chmod 755 /home/dsas
      # remount main disk as noexec. Strip trail "/dsas" from $DSAS to get the real partition
      mount -o remount,noexec,nodev,nosuid "${DSAS:0:-5}"
      mount --noexec --nobind "$DSAS" /home/dsas
    fi
    # For persistent /var/log taht are also accessible by the tc user. Do this before launching syslog
    [ -d "${DSAS:0:-5}/log" ] && chmod g+s "${DSAS:0:-5}/log" && chgrp staff -R "${DSAS:0:-5}/log"
    [ -d "${DSAS:0:-5}/log" ] && [ ! "$(mounted /var/log)" ] && mount "${DSAS:0:-5}/log" /var/log
  else
    [ -L /home/dsas ] || ln -s "$DSAS" /home
    # If docker a persisent /var/log can be a symlink
    mv /var/log var/log.old
    ln -s "${DSAS:0:-5}/log" /var/log
  fi
  chown root.staff /home/dsas
  chmod 755 /home/dsas
}

init_disk(){
  [ -z "$ISDOCKER" ] && FDISKL=$(fdisk -l | awk '$1 ~ /dev/{printf " %s ",$1}')
  [ -z "$ISDOCKER" ] || FDISKL=$(grep "^/dev/" /etc/mtab | cut -f1 -d' ' | uniq)
  FOUND=""
  DISK=""
  ARGS="--stdout --no-cancel --radiolist 'Select device to format for the DSAS:' 0 0 0"
  ON="on"
  # Loop through block devices
  while IFS= read -r -d '' i; do
    case "$i" in
      *loop*|*ram*)
        continue
        ;;
    esac

    DEVNAME=$(echo "$i" | tr "!" "/" | awk 'BEGIN{FS="/"}{print $(NF-1)}')
    DEVMAJOR="$(cut -f1 -d: "$i")"
    [ "$DEVMAJOR" != '8' ] && continue
    for PART in $FDISKL; do
      case "$PART" in
        *"/dev/$DEVNAME"*)
          FOUND=$DEVNAME
          MOUNTPOINT=$(echo "$PART" | sed -e "s:.*\($DEVNAME.*\):/mnt/\1:g")
          [ -d "$MOUNTPOINT" ] || mkdir "$MOUNTPOINT"
          mount | grep -q "$PART" || mount "$PART" "$MOUNTPOINT"
          break
          ;;
      esac
    done
    SIZE="$(($(cat "/sys/block/$DEVNAME/size") / 2))"
    for SUF in MB GB TB PB; do
      REM=$(($((SIZE % 1000)) / 10))
      SIZE=$((SIZE / 1000))
      [ $SIZE -lt 1000 ] && break
    done
    DISK="1"
    if [ "$REM" -lt 1 ]; then
      ARGS="$ARGS /dev/$DEVNAME '/dev/$DEVNAME [$SIZE$SUF]' $ON"
    elif [ "$REM" -lt 100 ]; then
      ARGS="$ARGS /dev/$DEVNAME '/dev/$DEVNAME [$SIZE.0$REM$SUF]' $ON"
    else
      ARGS="$ARGS /dev/$DEVNAME '/dev/$DEVNAME [$SIZE.$REM$SUF]' $ON"
    fi
    ON="off"
  done < <(find /sys/block/*/ -mindepth 1 -maxdepth 1 -name dev -print0)

  if [ -z "$FOUND" ]; then
    if [ -z "$DISK" ]; then
      echo "${RED}No disk available for the DSAS. Aborting${NORMAL}"
      exit 1
    fi

    # No formatted disk found. Ask the user to format it
    DEV="$(echo "$ARGS" | xargs dialog)"
    echo "Creating partition table on ${GREEN}$DEV${NORMAL}"
    /sbin/fdisk "$DEV" << EOF > /dev/null 2>&1
n
p
1


w
EOF
    echo "Formatting ${GREEN}${DEV}1${NORMAL} as ${GREEN}EXT4${NORMAL}"
    /sbin/mkfs.ext4 "${DEV}1" > /dev/null 2>&1
    MNT="$(echo "$DEV" | sed -e 's/dev/mnt/')"
    mkdir -p "${MNT}1"
    echo "Mounting  ${GREEN}${DEV}1${NORMAL} on  ${GREEN}${MNT}1${NORMAL}"
    mount "${DEV}1" "${MNT}1"
    mkdir -p "${MNT}1/tce"
    chmod 770 "${MNT}1/tce"
    chown root.staff "${MNT}1/tce"
 
    return 1
  else
    echo "Found formatted disk : ${GREEN}/dev/$FOUND${NORMAL}"

    return 0
  fi
}

get_dsas(){
  while IFS= read -r -d '' d; do
    if [ -d "$d/bas" ] && [ -d "$d/haut" ]; then
      DSAS=$d
      echo "Found DSAS directories in ${GREEN}$DSAS${NORMAL}"    
      break;
    fi
  done < <(find "$MNT" -mindepth 2 -maxdepth 2 -type d -name "dsas" -print0)

  # First time the DSAS is run
  if [ -z "$DSAS" ]; then
    echo "Looking for disk to use for the ${GREEN}DSAS${NORMAL}"
    DISK=""
    # Find the largest partition that is mounted
    while IFS= read -r -d '' d; do
      if [ -z "$DISK" ]; then
        DISK=$d
        PART=$(basename "$DISK")
        DEV=$(echo "$PART" | sed -e "s/[[:digit:].*]$//g")
        SIZE=$(cat "/sys/block/$DEV/$PART/size")
      else
        PART=$(basename "$d")
        DEV=$(echo "$PART" | sed -e "s/[[:digit:].*]$//g")
        if [ "$(cat "/sys/block/$DEV/$PART/size")" -gt "$SIZE" ]; then
          DISK=$d
          SIZE=$(cat "/sys/block/$DEV/$PART/size")
        fi
      fi
    done < <(find "$MNT" -maxdepth 1 -type d -name "sd*" -print0)

    if [ -z "$DISK" ]; then
      echo "${RED}No disk available for the DSAS. Aborting${NORMAL}"
      exit 1
    fi

    # Now we can setup the disk for the first time
    echo "Creating DSAS directories in ${GREEN}$DISK/dsas${NORMAL}"

    for _user in bas haut; do
      mkdir -p "$DISK/dsas/$_user"
      chmod -R 750 "$DISK/dsas/$_user"
      chown -R "root.$_user" "$DISK/dsas/$_user"

      mkdir -p "$DISK/dsas/$_user/share"
      chmod -R 770 "$DISK/dsas/$_user/share"
      # g+s so that all files and subdirectories keep the same group
      chmod -R g+s "$DISK/dsas/$_user/share"
      chown -R "$_user.$_user" "$DISK/dsas/$_user/share"
    done
    # Files created by "verif" in /home/dsas/bas must have the group "share"
    chgrp -R share  "$DISK/dsas/bas/share"
    mkdir -p "$DISK/dsas/log"
    chmod -R 770 "$DISK/dsas/log"
    chown -R tc.verif "$DISK/dsas/log"
    mkdir -p "$DISK/log"
    chmod 750 "$DISK/log"
    chown root.staff "$DISK/log"
    DSAS=$DISK/dsas
  fi

  TCE=$(readlink /etc/sysconfig/tcedir)
  if [ -z "$TCE" ] || [ "${TCE:0:8}" = "/tmp/tce" ]; then
    TCE=$(echo "$DSAS" | sed -e "s:/dsas::")
    echo "Setting up TCE directory on ${GREEN}$TCE${NORMAL}"
    /usr/bin/tce-setdrive -s "$TCE"
    chmod -R o-rwx "$TCE/tce"
  fi
}

audit_perms(){
  # Suggestion form Lynis
  echo "Auditing USB permissions"
  while IFS= read -r -d '' dev; do
    echo "0" > "$dev/authorized"
    echo "0" > "$dev/authorized_default"
  done < <(find /sys/bus/usb/devices -name "usb*" -print0)

  echo "Auditing permissions of ${GREEN}$DSAS${NORMAL} in the background"
  grep -q users /etc/group || addgroup -g 51 users
  while IFS= read -r -d '' _d; do
    _d=$(basename "$_d")
    for _user in bas haut log; do
       [ "$_d" = "$_user" ] && break 2
    done
    chgrp -R users "$_d"
    chmod go-rwx "$_d"
  done < <(find "$DSAS" -type d -mindepth 1 -maxdepth 1 -print)
  chgrp verif "$DSAS/log"
  chmod 770 "$DSAS/log"
  chmod g+s "$DSAS/log"
  for _user in bas haut; do
    chown "root.$_user" "$DSAS/$_user"
    chmod 750 "$DSAS/$_user"
    chown "$_user.$_user" "$DSAS/$_user/share"
    chmod 770 "$DSAS/$_user/share"
    while IFS= read -r -d '' _d; do
      [ "$_user" = "bas" ] || chown haut.haut "$_d"
      [ "$_user" = "bas" ] && chown verif.share "$_d"
      chmod 770 "$_d"
    done < <(find "$DSAS/$_user/share" -mindepth 1 -type d -print0)
  done
  while IFS= read -r -d '' _f; do
    if [ "$(stat -c%h "$_f")" -eq 1 ]; then
      # not hardlinked so only in haut
      chown "$_user.$_user" "$_f"
      chmod 640 "$_f"
    fi
  done < <(find "$DSAS/haut/share" -type f -print0)
  while IFS= read -r -d '' _f; do
    chown verif.share "$_f"
    chmod 640 "$_f"
  done < <(find "$DSAS/bas/share" -type f -print0)
}

getnetdevices(){
  # The order of the interfaces returned by this function is extremely important
  # The interface between the upper and lower machines must be last. Docker is 
  # stupid and allocates randomly the names and order of the interfaces returned
  # by /proc/net/dev. I get around this by allocating an interface prefix (typically "doc")
  # that is alphabetically first to the principal interface
  _tmp="$(awk -F: 'NR>2&&!/lo:|dummy.:|tunl.:/{print $1}' /proc/net/dev 2>/dev/null)"

  # Use xargs to ensure one space between devices
  echo -e "$(echo "$_tmp" | xargs -n1 | sort -)" | xargs
}  
  
valid_ip(){
  if [[ $1 =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
    for i in 1 2 3 4; do
      [ "$(echo "$1" | cut -d. -f$i)" -gt 255 ] && return 1
    done
    return 0
  else
    return 1
  fi
}

valid_cidr() {
  mask=$(echo "$1" | sed -e "s:^.*/\(.*\)$:\1:")
  ip=$(echo "$1" | sed -e "s:^\(.*\)/.*$:\1:")
  [[ "$mask" =~ ^[0-9]+$ ]] || return 1
  [ "$mask" -gt 32 ] && return 1
  valid_ip "$ip" || return 1 
  return 0
}

config_interco(){
    c=$(xmllint --xpath 'string(dsas/config/network/interco/haut/cidr)' "$VAR/dsas_conf.xml")
    while :; do
      INTERCO_CIDR="$(dialog --stdout --no-cancel --title 'Upper interconnexion network in CIDR format' --inputbox 'Address:' 0 0 "$c")"
      valid_cidr "$INTERCO_CIDR" || { dialog --msgbox "IP Address invalid" 0 0; continue; }
      _cidr="$(echo "$INTERCO_CIDR" | sed -e "s:^.*/\(.*\)$:\1:")"
      if [ "$_cidr" -lt 24 ] || [ "$_cidr" -gt 30 ] ; then
        dialog --msgbox "CIDR must be between 24 and 30 invalid" 0 0
        continue
      fi
      break
    done
    if [ "$INTERCO_CIDR" != "$c" ]; then
      echo -e "cd /dsas/config/network/interco/haut/cidr\nset $INTERCO_CIDR\nsave" | xmllint --shell $VAR/dsas_conf.xml > /dev/null
    fi
    g=$(xmllint --xpath 'string(dsas/config/network/interco/haut/gateway)' "$VAR/dsas_conf.xml")
    while :; do
      INTERCO_GW="$(dialog --stdout --no-cancel --title 'Upper interconnexion gateway' --inputbox 'Address:' 0 0 "$g")"
      [ -z "$INTERCO_GW" ] && break
      valid_ip "$INTERCO_GW" && break
      dialog --msgbox "IP Address invalid" 0 0
    done
    if [ "$INTERCO_GW" != "$g" ]; then
      echo -e "cd /dsas/config/network/interco/haut/gateway\nset $INTERCO_GW\nsave" | xmllint --shell $VAR/dsas_conf.xml > /dev/null
    fi
    c=$(xmllint --xpath 'string(dsas/config/network/interco/bas/cidr)' "$VAR/dsas_conf.xml")
    while :; do
      INTERCO_CIDR="$(dialog --stdout --no-cancel --title 'Lower interconnexion network in CIDR format' --inputbox 'Address:' 0 0 "$c")"
      valid_cidr "$INTERCO_CIDR" || { dialog --msgbox "IP Address invalid" 0 0; continue; }
      _cidr="$(echo "$INTERCO_CIDR" | sed -e "s:^.*/\(.*\)$:\1:")"
      if [ "$_cidr" -lt 24 ] || [ "$_cidr" -gt 30 ] ; then
        dialog --msgbox "CIDR must be between 24 and 30 invalid" 0 0
        continue
      fi
      break
    done
    if [ "$INTERCO_CIDR" != "$c" ]; then
      echo -e "cd /dsas/config/network/interco/bas/cidr\nset $INTERCO_CIDR\nsave" | xmllint --shell $VAR/dsas_conf.xml > /dev/null
    fi
    g=$(xmllint --xpath 'string(dsas/config/network/interco/bas/gateway)' "$VAR/dsas_conf.xml")
    while :; do
      INTERCO_GW="$(dialog --stdout --no-cancel --title 'Lower interconnexion gateway' --inputbox 'Address:' 0 0 "$g")"
      [ -z "$INTERCO_GW" ] && break
      valid_ip "$INTERCO_GW" && break
      dialog --msgbox "IP Address invalid" 0 0
    done
    if [ "$INTERCO_GW" != "$g" ]; then
      echo -e "cd /dsas/config/network/interco/bas/gateway\nset $INTERCO_GW\nsave" | xmllint --shell "$VAR/dsas_conf.xml" > /dev/null
    fi
}

setup_interco(){
    INTERCO_CIDR_HAUT=$(xmllint --xpath 'string(dsas/config/network/interco/haut/cidr)' "$VAR/dsas_conf.xml")
    _cidr="$(echo "$INTERCO_CIDR_HAUT" | sed -e "s:^.*/\(.*\)$:\1:")"
    INTERCO_HAUT=$(echo "$INTERCO_CIDR_HAUT" | sed -e "s:^\(.*\)/.*$:\1:")
    INTERCO_MASK_HAUT="255.255.255.$(( (255 << (32 - _cidr)) & 255))"
    _last="$(($(echo "$INTERCO_HAUT" | cut -d. -f4) & ((0xFF00 << (_cidr - 24)) & 0xFF)))" 
    INTERCO_CIDR_HAUT="$(echo "$INTERCO_HAUT" | cut -d. -f1-3).$_last"   

    INTERCO_CIDR_BAS=$(xmllint --xpath 'string(dsas/config/network/interco/bas/cidr)' "$VAR/dsas_conf.xml")
    _cidr="$(echo "$INTERCO_CIDR_BAS" | sed -e "s:^.*/\(.*\)$:\1:")"
    INTERCO_BAS=$(echo "$INTERCO_CIDR_BAS" | sed -e "s:^\(.*\)/.*$:\1:")
    INTERCO_MASK_BAS="255.255.255.$(( (255 << (32 - _cidr)) & 255))"
    _last="$(($(echo "$INTERCO_BAS" | cut -d. -f4) & ((0xFF00 << (_cidr - 24)) & 0xFF)))" 
    INTERCO_CIDR_BAS="$(echo "$INTERCO_BAS" | cut -d. -f1-3).$_last" 

    if [ "$INTERCO_CIDR_BAS" != "$INTERCO_CIDR_HAUT" ] || [ "$INTERCO_MASK_BAS" != "$INTERCO_MASK_HAUT" ]; then
      # The two machines of the DSAS are on different lans. Need to configure the gateways
      INTERCO_GW_HAUT=$(xmllint --xpath 'string(dsas/config/network/interco/haut/gateway)' "$VAR/dsas_conf.xml")
      INTERCO_GW_BAS=$(xmllint --xpath 'string(dsas/config/network/interco/bas/gateway)' "$VAR/dsas_conf.xml")
    else
      INTERCO_GW_HAUT=""
      INTERCO_GW_BAS=""
    fi
}

valid_domain(){
  [ ${#1} -lt 4 ] && return 1
  [ ${#1} -gt 253 ] && return 1
  echo "$1" | grep -E '^[a-z0-9][a-z0-9-]{0,63}(\.[a-z0-9][a-z0-9-]{0,63}){1,}$' || return 1
  return 0
}

config_network(){
  d=$(xmllint --xpath 'string(dsas/config/network/bas/dhcp)' "$VAR/dsas_conf.xml")
  if [ "$d" = "true" ]; then
    d="on"
  else
    d="off"
  fi
  DHCP="$(dialog --stdout --no-cancel --checklist 'Interface Bas:' 0 0 0 on 'DHCP' $d)"
  if [ "$DHCP" != "$d" ]; then
    if [ "$DHCP" = "on" ]; then
      echo -e "cd /dsas/config/network/bas/dhcp\nset true\nsave" | xmllint --shell $VAR/dsas_conf.xml
    else
      echo -e "cd /dsas/config/network/bas/dhcp\nset false\nsave" | xmllint --shell $VAR/dsas_conf.xml
    fi
  fi

  if [ "$DHCP" != "on" ]; then
    # Static IP. Configure the rest of the interface
    c=$(xmllint --xpath 'string(dsas/config/network/bas/cidr)' "$VAR/dsas_conf.xml")
    while :; do
      CIDR="$(dialog --stdout --no-cancel --title 'IP Address in CIDR format' --inputbox 'Address:' 0 0 "$c")"
      valid_cidr "$CIDR" && break;
      dialog --msgbox "IP Address invalid" 0 0
    done
    if [ "$CIDR" != "$c" ]; then
      echo -e "cd /dsas/config/network/bas/cidr\nset $CIDR\nsave" | xmllint --shell "$VAR/dsas_conf.xml" > /dev/null
    fi

    g=$(xmllint --xpath 'string(dsas/config/network/bas/gateway)' "$VAR/dsas_conf.xml")
    while :; do
      GWAY="$(dialog --stdout --no-cancel --title 'Gateway IP Address' --inputbox 'Address:' 0 0 "$g")"
      [ -z "$GWAY" ] && break
      valid_ip "$GWAY" && break
      dialog --msgbox "IP Address invalid" 0 0
    done
    if [ "$GWAY" != "$g" ]; then
      echo -e "cd /dsas/config/network/bas/gateway\nset $GWAY\nsave" | xmllint --shell "$VAR/dsas_conf.xml" > /dev/null
    fi

    d=$(xmllint --xpath 'string(dsas/config/network/bas/dns/domain)' "$VAR/dsas_conf.xml")
    while :; do
      DOMAIN="$(dialog --stdout --no-cancel --title 'DNS search domain' --inputbox 'Domain:' 0 0 "$d")"
      [ -z "$DOMAIN" ] && break
      valid_domain "$DOMAIN" && break
      dialog --msgbox "Domain invalid" 0 0
    done
    if [ "$DOMAIN" != "$d" ]; then
      echo -e "cd /dsas/config/network/bas/dns/domain\nset $DOMAIN\nsave" | xmllint --shell $VAR/dsas_conf.xml > /dev/null
    fi

    S=$(xmllint --xpath "string(dsas/config/network/bas/dns/nameserver)" "$VAR/dsas_conf.xml")
    NS="$S"
    i=2
    while [ -n "$S" ]; do
      S=$(xmllint --xpath "string(dsas/config/network/bas/dns/nameserver[$i])" "$VAR/dsas_conf.xml")
      [ -n "$S" ] && NS="$NS $S"
      i=$((i+1))
    done
    while :; do
      NAME="$(dialog --stdout --no-cancel --title 'DNS name servers' --inputbox 'Nameservers:' 0 0 "$NS")"
      if [ "$NAME" != "$NS" ]; then
        ARGS="cd /dsas/config/network/bas/dns\nset <domain>$DOMAIN</domain>"
        if [ -z "${NAME// }" ]; then
          ARGS="${ARGS}<nameserver />"
        else
          for S in $NAME; do
            if  ! valid_ip "$S"; then 
              dialog --msgbox "IP Address invalid" 0 0
              continue 2
            fi
            ARGS="${ARGS}<nameserver>$S</nameserver>"
            i=$((i + 1))
          done
        fi
        ARGS="${ARGS}\nsave"
        echo -e "$ARGS" | xmllint --shell $VAR/dsas_conf.xml
      fi
      break;
    done
  fi
}

start_network(){
  NETDEVICES=$(getnetdevices)
  if [ "$(echo "$NETDEVICES" | wc -w)" -lt 2 ]; then
    echo "${RED}At least two network devices are needed. Aborting !!${NORMAL}"
    exit 1
  fi

  # Setup loopback
  /sbin/ifconfig lo 127.0.0.1 up
  route | grep -q 127.0.0.1 || /sbin/route add 127.0.0.1 lo &

  ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
  ETH1=$(echo "$NETDEVICES" | cut -d" " -f2)

  if [ -z "$NO_INTERCO" ]; then
    echo "Using static IP for ${GREEN}$ETH1${NORMAL}."
    if [ "$TYP" = "bas" ]; then
      /sbin/ifconfig "$ETH1" "$INTERCO_BAS" netmask "$INTERCO_MASK_BAS" up
      if [ -z "$INTERCO_GW_BAS" ]; then
        /sbin/route add "$INTERCO_HAUT" "$ETH1" &
      else
        /sbin/route add "$INTERCO_HAUT" gw "$INTERCO_GW_BAS" "$ETH1" &
      fi
    else
      /sbin/ifconfig "$ETH1" "$INTERCO_HAUT" netmask "$INTERCO_MASK_HAUT" up
      if [ -z "$INTERCO_GW_HAUT" ]; then
        /sbin/route add "$INTERCO_BAS" "$ETH1" &
      else
        /sbin/route add "$INTERCO_BAS" gw "$INTERCO_GW_HAUT" "$ETH1" &
      fi
    fi
  fi

  dhcp=$(xmllint --xpath "string(dsas/config/network/${TYP}/dhcp)" "$VAR/dsas_conf.xml")
  if [ "$dhcp" = "true" ]; then
    echo -n "Using DHCP broadcast for ${GREEN}$ETH0${NORMAL}..."
    /sbin/udhcpc -b -i "$ETH0" -x "hostname:$(/bin/hostname)" -p "/var/run/udhcpc.$ETH0.pid" > /dev/null 2>&1 &
    CNT=0
    until ifconfig | grep -q Bcast; do
      [ $((CNT++)) -gt 60 ] && break
      sleep 1
    done
    sleep 1
    [ "$CNT" -gt 60 ] && echo "${RED}Fail${NORMAL}"
    [ "$CNT" -le 60 ] && echo "${GREEN}Ok${NORMAL}"          
  else
    echo "Using static IP for ${GREEN}$ETH0${NORMAL}."
    cidr=$(xmllint --xpath "string(dsas/config/network/${TYP}/cidr)" "$VAR/dsas_conf.xml")
    IP=$(echo "$cidr" | sed -e "s:^\(.*\)/.*$:\1:")
    mask=$(echo "$cidr" | sed -e "s:^.*/\(.*\)$:\1:")
    value=$(( 0xffffffff ^ ((1 << (32 - mask)) - 1) ))
    NET="$(( (value >> 24) & 0xff )).$(( (value >> 16) & 0xff )).$(( (value >> 8) & 0xff )).$(( value & 0xff ))"
    GWAY=$(xmllint --xpath "string(dsas/config/network/${TYP}/gateway)" "$VAR/dsas_conf.xml")
    DOMAIN=$(xmllint --xpath "string(dsas/config/network/${TYP}/dns/domain)" "$VAR/dsas_conf.xml")

    /sbin/ifconfig "$ETH0" "$IP" netmask "$NET" up
    [ -z "$GWAY" ] || /sbin/route add default gw "$GWAY" &
    [ -z "$DOMAIN" ] || echo -e "search $DOMAIN" > /etc/resolv.conf
    NS=$(xmllint --xpath "string(dsas/config/network/${TYP}/dns/nameserver)" "$VAR/dsas_conf.xml")
    i=2
    while :; do
      [ -z "${NS// }" ] && break
      echo -e "nameserver $NS" >> /etc/resolv.conf
      NS=$(xmllint --xpath "string(dsas/config/network/${TYP}/dns/nameserver[$i])" "$VAR/dsas_conf.xml")
      i=$((i+1))
    done
  fi
}

stop_network(){
  NETDEVICES=$(getnetdevices)
  ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
  ETH1=$(echo "$NETDEVICES" | cut -d" " -f2)
  GWAY=$(xmllint --xpath "string(dsas/config/network/${TYP}/gateway)" "$VAR/dsas_conf.xml.active")
  [ -n "$GWAY" ] && /sbin/route del default gw "$GWAY"
  pkill udhcpc
  /sbin/ifconfig "$ETH0" down

  if [ -z "$NO_INTERCO" ]; then
    [ "$TYP" = "bas" ] && /sbin/route del "$INTERCO_HAUT"
    [ "$TYP" = "haut" ] && /sbin/route del "$INTERCO_BAS"

    /sbin/ifconfig "$ETH1" down
  fi
  /sbin/ifconfig lo down
}

start_web_admin(){
  cp "$VAR/admin.conf.dsas" "$VAR/admin.conf"
  chown root.staff $VAR/admin.conf $VAR/admin.conf.dsas
  chmod 640 $VAR/admin.conf $VAR/admin.conf.dsas
  NETDEVICES=$(getnetdevices)
  ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
  ip=$(ifconfig "$ETH0" | sed -rn "2s/[^:]*:([.[:digit:]]*).*/\1/p") 
  echo "Binding webserver to ${GREEN}$ETH0${NORMAL} and address ${GREEN}$ip${NORMAL}." 
  echo "server.bind = \"$ip\"" >> $VAR/admin.conf
  echo "Starting administration web server"
  $as_tc lighttpd -Df "$VAR/admin.conf" > /dev/null 2>&1 &
}

stop_web_admin(){
  pkill -f admin.conf
}

start_sshd(){
  if [ "$TYP" = "bas" ]; then
    [ "$(xmllint --xpath "string(dsas/config/ssh/active)" "$VAR/dsas_conf.xml")" = "false" ] && { stop_sshd; return 0; }
    USER_TC=$(xmllint --xpath "string(dsas/config/ssh/user_tc)" "$VAR/dsas_conf.xml") 
    USER=$(xmllint --xpath "string(dsas/config/ssh/user_bas)" "$VAR/dsas_conf.xml")
    UID_TC=""
    i=1
    while :; do
      _username=$(xmllint --xpath "string(dsas/config/users/user[$i]/username)" "$VAR/dsas_conf.xml")
      [ -z "${_username// }" ] && break
      _active=$(xmllint --xpath "string(dsas/config/users/user[$i]/active)" "$VAR/dsas_conf.xml")
      _type=$(xmllint --xpath "string(dsas/config/users/user[$i]/type)" "$VAR/dsas_conf.xml")
      if [ "$_active" = "true" ] && [ "$_type" = "admin" ]; then
        if [ -z "$UID_TC" ]; then
          UID_TC="$_username"
        else
          UID_TC="$UID_TC,$_username"
        fi
      fi
      i=$((i + 1))
    done
    UID_TYP=""
    i=1
    while :; do
      _username=$(xmllint --xpath "string(dsas/config/users/user[$i]/username)" "$VAR/dsas_conf.xml")
      [ -z "${_username// }" ] && break
      _active=$(xmllint --xpath "string(dsas/config/users/user[$i]/active)" "$VAR/dsas_conf.xml")
      _type=$(xmllint --xpath "string(dsas/config/users/user[$i]/type)" "$VAR/dsas_conf.xml")
      if [ "$_active" = "true" ] && [ "$_type" = "$TYP" ]; then
        if [ -z "$UID_TYP" ]; then
          UID_TYP="$_username"
        else
          UID_TYP="$UID_TYP,$_username"
        fi
      fi
      i=$((i + 1))
    done
    NETDEVICES=$(getnetdevices)
    ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
    LISTEN=$(ifconfig "$ETH0" | sed -rn "2s/[^:]*:([.[:digit:]]*).*/\1/p") 
  else
    USER_TC="$INTERCO_BAS"
    USER=$(xmllint --xpath "string(dsas/config/ssh/user_haut)" "$VAR/dsas_conf.xml")
    UID_TC="tc"
    UID_TYP=""
    i=1
    while :; do
      _username=$(xmllint --xpath "string(dsas/config/users/user[$i]/username)" "$VAR/dsas_conf.xml")
      [ -z "${_username// }" ] && break
      _active=$(xmllint --xpath "string(dsas/config/users/user[$i]/active)" "$VAR/dsas_conf.xml")
      _type=$(xmllint --xpath "string(dsas/config/users/user[$i]/type)" "$VAR/dsas_conf.xml")
      if [ "$_active" = "true" ] && [ "$_type" = "$TYP" ]; then
        if [ -z "$UID_TYP" ]; then
          UID_TYP="$_username"
        else
          UID_TYP="$UID_TYP,$_username"
        fi
      fi
      i=$((i + 1))
    done
    if [ -z "$USER" ]; then
      LISTEN="$INTERCO_HAUT"
    else
      LISTEN="0.0.0.0"
      # Exclude the machine bas
      [[ "$USER" =~ "/0$" ]] && USER="$USER,!$INTERCO_BAS"
    fi
  fi

  # Setup groups to allow access by sftp to the users
  if [ -z "$UID_TYP" ]; then
    sed -i -e "s/\($TYP:.*\):verif\(.*\)$/\1:verif/" /etc/group
    sed -i -e "s/\(share:.*\):verif,bas,haut\(.*\)$/\1:verif,bas,haut/" /etc/group
  else
    sed -i -e "s/\($TYP:.*\):verif\(.*\)$/\1:verif,$UID_TYP/" /etc/group
    sed -i -e "s/\(share:.*\):verif,bas,haut\(.*\)$/\1:verif,bas,haut,$UID_TYP/" /etc/group
  fi

  [ -z "$USER_TC" ] && [ -z "$USER" ] && { stop_sshd; return 0; }
  cp -f /usr/local/etc/ssh/sshd_config.dsas /usr/local/etc/ssh/sshd_config
  if [ -n "$USER_TC" ] && [ -n "$UID_TC" ]; then
    cat << EOF >> /usr/local/etc/ssh/sshd_config

ListenAddress $LISTEN

Match User $UID_TC Address $USER_TC
	PasswordAuthentication yes
	PubkeyAuthentication yes

EOF
  fi

  if [ -n "$USER" ] && [ -n "$UID_TYP" ]; then
    cat << EOF >> /usr/local/etc/ssh/sshd_config
Match User $UID_TYP Address $USER
	PasswordAuthentication yes
	PubkeyAuthentication yes
	ChrootDirectory /home/dsas/$TYP
	X11Forwarding no
	AllowTcpForwarding no
	AllowAgentForwarding no
	ForceCommand internal-sftp -u 0007 -d /share

EOF
  fi

  if [ "$TYP" = "haut" ]; then
    cat << EOF >> /usr/local/etc/ssh/sshd_config
Match User bas Address $INTERCO_BAS
	PasswordAuthentication yes
	PubkeyAuthentication yes
	ChrootDirectory /home/dsas/bas
	X11Forwarding no
	AllowTcpForwarding no
	AllowAgentForwarding no
	ForceCommand internal-sftp -u 0007 -d /share

EOF
  fi

  if [ -n "$SSHD_SIGHUP" ] && [ -f /var/run/sshd.pid ]; then
    PID=$(cat /var/run/sshd.pid)
    if [ -d "/proc/$PID" ]; then
      echo "Sending ${GREEN}SIGHUP${NORMAL} to the ${GREEN}openssh${NORMAL} server"
      kill -HUP "$PID"
    else
      echo "Starting the ${GREEN}openssh${NORMAL} server"
      /usr/local/etc/init.d/openssh start >> /var/log/sshd.log 2>&1
    fi
  else
    echo "Starting the ${GREEN}openssh${NORMAL} server"
    /usr/local/etc/init.d/openssh start >> /var/log/sshd.log 2>&1
  fi
}

config_sshd(){
  if [ "$TYP" = "bas" ]; then
    # Wait for machine haut to become available
    i=0
    echo -ne "Waiting for SSH server on machine haut /"
    while :; do
      case $(($((i++)) % 4)) in
        0)
          echo -ne "\b-"
          ;;
        1)
          echo -ne "\b\\"
          ;;
        2)
          echo -ne "\b|"
          ;;
        3)
          echo -ne "\b/"
          ;;
      esac 
      ping -W 1 -c 1 "$INTERCO_HAUT" > /dev/null  2>&1 && break
    done
    echo -e "\b"
    echo "SSH server on machine haut available"
 
    echo "Generating user SSH keys"
    $as_tc ssh-keygen -b 4096 -t rsa -f /home/tc/.ssh/id_rsa -q -N ''
    $as_haut ssh-keygen -b 4096 -t rsa -f /home/haut/.ssh/id_rsa -q -N ''

    echo "Copying public keys to machine haut"
    $as_tc ssh-keyscan "$INTERCO_HAUT" > /home/tc/.ssh/known_hosts
    $as_tc ssh-keyscan haut >> /home/tc/.ssh/known_hosts
    cp /home/tc/.ssh/known_hosts /home/haut/.ssh/known_hosts
    chown tc.staff /home/tc/.ssh/known_hosts
    chown haut.haut /home/haut/.ssh/known_hosts
    PASSWD="dSaO2021DSAS"  # Try default password first

    # Don't use $as_tc here as don't want the "-E"
    while ! sudo -u tc /usr/local/bin/sshpass -p "$PASSWD" ssh-copy-id -i /home/tc/.ssh/id_rsa.pub -f "tc@$INTERCO_HAUT" ; do
      # FIXME Sleep to allow any error messages to be seen. Maybe remove later
      sleep 5
      dialog --msgbox "Password incorrect" 0 0
      PASSWD="$(dialog --stdout --no-cancel --insecure --passwordbox 'Password user tc:' 0 0)"
    done

    cp /home/haut/.ssh/id_rsa.pub /tmp/authorized_keys
    chown tc.staff /tmp/authorized_keys
    chmod 600 /tmp/authorized_keys
    $as_tc scp /tmp/authorized_keys "tc@$INTERCO_HAUT:/tmp/authorized_keys"
    rm /tmp/authorized_keys
    $as_tc ssh "tc@$INTERCO_HAUT" << EOF
sudo mkdir -p /home/bas/.ssh
cat /tmp/authorized_keys >> /home/tc/.ssh/authorized_keys
sudo mv -f /tmp/authorized_keys /home/bas/.ssh/authorized_keys
sudo chown -R bas.bas /home/bas/.ssh
sudo chmod -R 700 /home/bas/.ssh
EOF

    echo "Creating ssh keys"
    [ -f /usr/local/etc/ssh/ssh_host_rsa_key ] || /usr/local/bin/ssh-keygen -t rsa -N "" -f /usr/local/etc/ssh/ssh_host_rsa_key
    [ -f /usr/local/etc/ssh/ssh_host_dsa_key ] || /usr/local/bin/ssh-keygen -t dsa -N "" -f /usr/local/etc/ssh/ssh_host_dsa_key
    [ -f /usr/local/etc/ssh/ssh_host_ecdsa_key ] || /usr/local/bin/ssh-keygen -t ecdsa -N "" -f /usr/local/etc/ssh/ssh_host_ecdsa_key
    [ -f /usr/local/etc/ssh/ssh_host_ed25519_key ] || /usr/local/bin/ssh-keygen -t ed25519 -N "" -f /usr/local/etc/ssh/ssh_host_ed25519_key

    echo "Backing up authorized keys on machine haut"
    $as_tc ssh -i /home/tc/.ssh/id_rsa "tc@$INTERCO_HAUT" filetool.sh -b
  fi
}

stop_sshd(){
  pkill sshd
}

start_repo(){
  repo="$(xmllint --xpath 'string(dsas/config/web/repo)' "$VAR/dsas_conf.xml")"
  if [ "$repo" != "true" ]; then return 0; fi
  cp "$VAR/repo.conf.dsas" "$VAR/repo.conf"
  chown root.repo $VAR/repo.conf $VAR/repo.conf.dsas
  chmod 640 $VAR/repo.conf $VAR/repo.conf.dsas
  NETDEVICES=$(getnetdevices)
  ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
  ip=$(ifconfig "$ETH0" | sed -rn "2s/[^:]*:([.[:digit:]]*).*/\1/p") 
  echo "Binding repo to ${GREEN}$ETH0${NORMAL} and address ${GREEN}$ip${NORMAL}." 
  echo "server.bind = \"$ip"\" >> $VAR/repo.conf
  echo "Starting repository web server"
  # Start as root to allow use of port 443. But after change to user bas.repo
  # via options in repo.conf
  lighttpd -Df "$VAR/repo.conf" > /dev/null 2>&1 &
}

stop_repo(){
  pkill -f repo.conf
}

start_syslog(){
  syslog=$(xmllint --xpath "string(dsas/config/syslog/active)" "$VAR/dsas_conf.xml")
  server=$(xmllint --xpath "string(dsas/config/syslog/server)" "$VAR/dsas_conf.xml")

  if [ "$syslog" = "true" ]; then
    [ "$TYP" = "bas" ] && [ -n "$server" ] && sopts=" -R $server -L "
    sopts=" -l 5 $sopts"
    echo "${sopts}" | xargs /sbin/syslogd && echo "${GREEN}syslogd started.${NORMAL}"
    /sbin/klogd && echo "${GREEN}klogd started.${NORMAL}"
  fi
}

stop_syslog(){
  pkill klog
  pkill syslog
}

start_ntp(){
  # FIXME Use "-S" option of busybox ntpd to get information from service
  ntp=$(xmllint --xpath "string(dsas/config/ntp/active)" "$VAR/dsas_conf.xml")
  next=$(xmllint --xpath "string(dsas/config/ntp/server[1])" "$VAR/dsas_conf.xml")

  if [ "$ntp" = "true" ] && [ "$next" != "" ]; then
    i=2
    opts=""
    while [ -n "$next" ]; do
      opts="$opts -p $next"
      next=$(xmllint --xpath "string(dsas/config/ntp/server[$i])" "$VAR/dsas_conf.xml")
      i=$((i+1))
    done
    echo "${opts}" | xargs /usr/sbin/ntpd && echo "${GREEN}ntpd started.${NORMAL}"
  fi
}

stop_ntp(){
  pkill ntpd
}

start_radius(){
  mkdir -p "$(dirname "$RADIUS_SERVER")"
  chmod 750 "$(dirname "$RADIUS_SERVER")"
  chown root.staff "$(dirname "$RADIUS_SERVER")"
  radius=$(xmllint --xpath "string(dsas/config/radius/active)" "$VAR/dsas_conf.xml")
  server=$(xmllint --xpath "string(dsas/config/radius/server)" "$VAR/dsas_conf.xml")
  secret=$(xmllint --xpath "string(dsas/config/radius/secret)" "$VAR/dsas_conf.xml")

  [ "$radius" != "true" ] && return
  [ -z "$server" ] && return
  [ -z "$secret" ] && return
  echo "Configuring radius client to use the server ${GREEN}$server${NORMAL}." 
  echo "# server[:port]                   shared_secret                 timeout(s)    source_ip      vrf" > $RADIUS_SERVER
  printf "%-32s %-32s %-4s" "$server" "$secret" "3" >> $RADIUS_SERVER
  chmod 750 "$RADIUS_SERVER"
  chown root.staff "$RADIUS_SERVER"
  sed -i -e '2s:^:auth           [success=3 ignore=ignore default=2]      pam_radius_auth.so localifdown conf=/etc/raddb/server\n:' /usr/local/etc/pam.d/common-auth
}

stop_radius(){
  sed -i -e '/^.*pam_radius_auth.so.*/d' /usr/local/etc/pam.d/common-auth
  rm $RADIUS_SERVER > /dev/null 2>&1
}

start_antivirus(){
  antivirus=$(xmllint --xpath "string(dsas/config/antivirus/active)" "$VAR/dsas_conf.xml")
  if [ "$antivirus" = "true" ]; then
    ClamAVDir="/etc/sysconfig/tcedir/../dsas/bas/share/ClamAV"
    if [ -n "$ClamAVDir" ]; then
      mkdir -p $ClamAVDir
      chown verif.share $ClamAVDir
    fi
    # Start up is slow. So need to background. Also send output to /dev/null so that
    # web UI doesn't block waiting for clamd to fork after the initialisation
    sudo -u verif /usr/local/sbin/clamd > /dev/null 2>&1 &
  fi
}

stop_antivirus(){
  pkill clamd
}

start_snmp(){
  snmp=$(xmllint --xpath "string(dsas/config/snmp/active)" "$VAR/dsas_conf.xml")
  if [ "$snmp" = "true" ]; then
    NETDEVICES=$(getnetdevices)
    ETH0=$(echo "$NETDEVICES" | cut -d" " -f1)
    ip=$(ifconfig "$ETH0" | sed -rn "2s/[^:]*:([.[:digit:]]*).*/\1/p") 
    snmp_username=$(xmllint --xpath "string(dsas/config/snmp/username)" "$VAR/dsas_conf.xml")
    snmp_password=$(xmllint --xpath "string(dsas/config/snmp/password)" "$VAR/dsas_conf.xml")
    snmp_encrypt=$(xmllint --xpath "string(dsas/config/snmp/encrypt)" "$VAR/dsas_conf.xml")
    snmp_passpriv=$(xmllint --xpath "string(dsas/config/snmp/passpriv)" "$VAR/dsas_conf.xml")
    snmp_privencrypt=$(xmllint --xpath "string(dsas/config/snmp/privencrypt)" "$VAR/dsas_conf.xml")
    dsas_oid=$(grep "OID=" /usr/local/sbin/snmpdsas | cut -d= -f2)
    mkdir -p /usr/local/etc/snmp
    chown root.staff /usr/local/etc/snmp
    chmod 750 /usr/local/etc/snmp
    cat << EOF > /usr/local/etc/snmp/snmpd.conf
agentAddress udp:$ip:161
CreateUser $snmp_username $snmp_encrypt $snmp_password $snmp_privencrypt $snmp_passpriv
rouser $snmp_username priv 1
pass $dsas_oid /usr/local/sbin/snmpdsas
EOF
    /usr/local/sbin/snmpd &
  fi
}

stop_snmp(){
  pkill snmpd
}

start_chroot(){
 if [ -z "$ISDOCKER" ]; then
   echo "Setting up ${GREEN}lftp chroot jail${NORMAL}"
   if [ ! "$(mounted /opt/lftp/home/dsas/haut)" ]; then
     # Create chroot jail for lftp as user haut
     mkdir -p  /opt/lftp/home/dsas/haut
     chown root.haut /opt/lftp/home/dsas/haut
     chmod 755 /opt/lftp/home/dsas
     chmod 750 /opt/lftp/home/dsas/haut
     mount --noexec --nobind /home/dsas/haut /opt/lftp/home/dsas/haut
   fi
   # At this point the ssh hosts and keys are setup. Link them to the chroot jail,
   # in a manner that they can't be abused to create an executable.
   # Don't mount /home/haut as this will give the user the capacity to create an executable
   [ -d "/opt/lftp/home/haut/.ssh" ] || mkdir -p /opt/lftp/home/haut/.ssh
   chmod 0550 /opt/lftp/home/haut /opt/lftp/home/haut/.ssh
   if [ "$TYP" = "bas" ]; then
     if [ "$1" = "--force" ]; then
       (umask 227; cp /home/haut/.ssh/ /opt/lftp/home/haut/.ssh)
     else
       for _f in /home/haut/.ssh/*; do
         [ -f "/opt/lftp/$_f" ] || cp "$_f" "/opt/lftp/$_f"
       done
     fi
     chmod 0440 /opt/lftp/home/haut/.ssh/id*
   else
     [ -f "/opt/lftp/home/haut/.ssh/known_hosts" ] || (umask 117; touch /opt/lftp/home/haut/.ssh/known_hosts)
   fi
   chown -R root.haut /opt/lftp/home/haut
   chmod 0660 /opt/lftp/home/haut/.ssh/known_hosts
   if [ ! "$(mounted /opt/lftp/dev/pts)" ]; then
     # Create pty for chroot jail
     (umask 00022; mkdir -p  /opt/lftp/dev/pts)
     mount -t devpts devpts /opt/lftp/dev/pts -o ptmxmode=0666,newinstance
     [ -e "/opt/lftp/dev/ptmx" ] || ln -r -s /opt/lftp/dev/pts/ptmx /opt/lftp/dev/ptmx
   fi
 fi
}

stop_chroot(){
  mounted /opt/lftp/home/dsas/haut && umount /opt/lftp/home/dsas/haut
  mounted /opt/lftp/dev && umount /opt/lftp/dev/pts
}

reboot_required(){
  echo -n "${YELLOW}Rebooting .${NORMAL}"
  for i in $(seq 1 1 5); do
    sleep 1
    echo -n " ."
  done
  /sbin/reboot
}

start_cron(){
  # Don't log cron messages, as too verbose
  crond -l 9
}

stop_cron(){
  pkill crond 
}

config_ssl(){
  [ -f "$VAR/dsas_priv.pem" ] && [ -f "$VAR/dsas_pub.pem" ] && [ -f "$VAR/dsas.pem" ] && [ -f "$VAR/dsas.csr" ] && return 0

  openssl req -new -newkey rsa:2048 -nodes -subj "/C=FR/ST=Paris/L=Paris/O=DSAS/OU=DSAS/CN=dsas.example.com"  -keyout "$VAR/dsas_priv.pem" -out "$VAR/dsas.csr"
  openssl req -x509 -sha256 -days 180 -subj "/C=FR/ST=Paris/L=Paris/O=DSAS/OU=DSAS/CN=dsas.example.com" -key "$VAR/dsas_priv.pem" -out "$VAR/dsas_pub.pem"
  cat "$VAR/dsas_priv.pem" "$VAR/dsas_pub.pem" > "$VAR/dsas.pem"
  chmod 640 "$VAR/dsas_priv.pem" "$VAR/dsas_pub.pem" "$VAR/dsas.pem" "$VAR/dsas.csr"
  chown tc.repo "$VAR/dsas_priv.pem" "$VAR/dsas_pub.pem" "$VAR/dsas.pem" "$VAR/dsas.csr"
}

save_config(){
  # Make a copy of the config file for later comparison
  $as_tc cp -f $VAR/dsas_conf.xml "$VAR/dsas_conf.xml.active"
  $as_tc chmod 640 $VAR/dsas_conf.xml "$VAR/dsas_conf.xml.active"
  $as_tc chown tc.verif $VAR/dsas_conf.xml "$VAR/dsas_conf.xml.active"

  echo "Saving DSAS configuration"
  $as_tc filetool.sh -b
}

check_xml_version(){
  _ver=$(xmllint --xpath "string(dsas/version)" "$VAR/dsas_conf.xml")
  # If no XML version set to first XML file with version number
  if [ -z "$_ver" ]; then
    echo "XML version added"
    # Don't use xmllint here as can't easily add nodes. Just use sed
    mv $VAR/dsas_conf.xml $VAR/dsas_conf.xml.old
    sed -i -e "s:<dsas>:<dsas>\n  <version>0.5</version>:" "$VAR/dsas_conf.xml"
    chown tc.staff $VAR/dsas_conf.xml
    chmod 644 $VAR/dsas_conf.xml
    _ver="0.5"
  fi
  VER_MAJOR="$(echo "$_ver" | cut -d. -f1)"
  VER_MINOR="$(echo "$_ver" | cut -d. -f2)"
  
  REAL_VER_MAJOR="$(echo $DSAS_XML_VERSION | cut -d. -f1)"
  REAL_VER_MINOR="$(echo $DSAS_XML_VERSION | cut -d. -f2)"
  if [ "$REAL_VER_MAJOR" -lt "$VER_MAJOR" ] || { [ "$REAL_VER_MAJOR" -eq "$VER_MAJOR" ] && [ "$REAL_VER_MINOR" -lt "$VER_MINOR" ]; }; then
    echo "${RED}Can not downgrade XML file.${NORMAL}"
    return
  fi

  # When the XML versions change add code here for the upgrade
  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "6" ]; then 
    sed -i -e "s:<network>:<network>\n      <interco>\n        <cidr>192.168.192.0/24</cidr>\n      </interco>:" $VAR/dsas_conf.xml
  fi
  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "7" ]; then 
    INTERCO_CIDR=$(xmllint --xpath 'string(dsas/config/network/interco/cidr)' "$VAR/dsas_conf.xml")
    _cidr="$(echo "$INTERCO_CIDR" | sed -e "s:^.*/\(.*\)$:\1:")"
    _ip=$(echo "$INTERCO_CIDR" | sed -e "s:^\(.*\)/.*$:\1:")
    _last="$(($(echo "$_ip" | cut -d. -f4) & ((0xFF00 << (_cidr - 24)) & 0xFF)))"
    INTERCO="$(echo "$_ip" | cut -d. -f1-3).$_last"   
    INTERCO_BAS="$(echo "$INTERCO" | cut -d. -f1-3).$(($(echo "$INTERCO" | cut -d. -f4) + 1))"
    INTERCO_HAUT="$(echo "$INTERCO" | cut -d. -f1-3).$(($(echo "$INTERCO" | cut -d. -f4) + 2))"
    INTERCO_GW="$(echo "$_ip" | cut -d. -f1-3).$((((0xFF << (32 - _cidr)) ^ 0xFF) & 0xFF + _last - 1))"
    cp "$VAR/dsas_conf.xml" "$VAR/dsas_conf.xml.old"
    awk '/^ +<\/interco>/ && found {found=""; next} /^ +<interco>/ {found=1} NF && !found'  "$VAR/dsas_conf.xml.old" \
        | sed -e "s:<network>:<network>\n      <interco>\n        <haut>\n          <cidr>$INTERCO_HAUT/$_cidr</cidr>\n          <gateway>$INTERCO_GW</gateway>\n        </haut>\n        <bas>\n          <cidr>$INTERCO_BAS/$_cidr</cidr>\n          <gateway>$INTERCO_GW</gateway>\n        </bas>\n      </interco>:" > $VAR/dsas_conf.xml
  fi
  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "8" ]; then 
    sed -i -e "s:</config>:<antivirus>\n        <active>false</active>\n        <uri></uri>\n      </antivirus>\n    </config>:" "$VAR/dsas_conf.xml"
  fi
  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "9" ]; then 
    _users="    <users>\n      $(xmllint --xpath 'dsas/config/users/hash' "$VAR/dsas_conf.xml")"
    _first=$(xmllint --xpath 'string(dsas/config/users/first)' "$VAR/dsas_conf.xml")
    [ -z "$_first" ] || _users="$_users\n      <first>true</first>"
    _users="$_users\n      <user>\n        <username>tc</username>\n        <description>Default account</description>\n        <type>admin</type>"
    _users="$_users\n        <active>true</active>\n      </user>\n    </users>"
    cp /var/dsas/dsas_conf.xml /var/dsas/dsas_conf.xml.old
    awk '/^ +<\/users>/ && found {found=""; next} /^ +<users>/ {found=1} NF && !found' $VAR/dsas_conf.xml.old \
        | sed -e "s:<config>:<config>\n$_users:" > $VAR/dsas_conf.xml
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "10" ]; then 
    sed -i -e "s:</config>:<snmp>\n        <active>false</active>\n        <username></username>\n        <password></password>\n      </snmp>\n    </config>:" $VAR/dsas_conf.xml
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "11" ]; then 
    sed -i -e "s:</antivirus>:  <uuid></uuid>\n      </antivirus>:" $VAR/dsas_conf.xml
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "12" ]; then
    _passpriv=$(xmllint --xpath 'string(dsas/config/snmp/password)' "$VAR/dsas_conf.xml")
    sed -i -e "s:</snmp>:  <encrypt>SHA</encrypt>\n        <passpriv>${_passpriv}</passpriv>\n        <privencrypt>AES</privencrypt>      </snmp>:" $VAR/dsas_conf.xml
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "13" ]; then
    # The version 0.13 of the DSAS needs the authorized_keys of "bas" copied to "tc"
    if [ -f "$VAR/dsas_typ" ] && [ "$(cat $VAR/dsas_typ)" = "haut" ]; then
      cat /home/bas/.ssh/authorized_keys >> /home/tc/.ssh/authorized_keys
      chown -R tc.staff /home/tc/.ssh
      chmod -R 700 /home/tc/.ssh
    fi
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "14" ]; then
    # The version 0.14 of the DSAS debian tasks with architectures defines
    sed -i -e "s:deb</type>:deb</type><archs><arch>all</arch><arch>amd64</arch></archs>:g"  $VAR/dsas_conf.xml
  fi

  if [ "$VER_MAJOR" -eq "0" ] && [ "$VER_MINOR" -lt "15" ]; then
    sed -i -e "s:</snmp>:</snmp>\n    <radius>\n      <active>false</active>\n      <server></server>\n      <secret></secret>\n    </radius>:g" $VAR/dsas_conf.xml
  fi

  # Now that the XML is upgraded, save the new version number
  if [ "$_ver" != "$DSAS_XML_VERSION" ]; then
    echo "XML version updated"
    echo -e "cd dsas/version\nset $DSAS_XML_VERSION\nsave" | xmllint --shell $VAR/dsas_conf.xml
  fi
}

case "${1}" in
  start)
    init_disk || reboot_required
    get_dsas
    mount_dsas
    audit_perms &
    check_xml_version

    NETDEVICES=$(getnetdevices)
    if [ "$(echo "$NETDEVICES" | wc -w)" -lt 2 ]; then
      echo "${RED}At least two network devices are needed. Aborting !!${NORMAL}"
      exit 1
    fi

    if [ -f "$VAR/dsas_typ" ]; then
      TYP="$(cat "$VAR/dsas_typ")"
      echo "Machine configured as type: ${GREEN}$TYP${NORMAL}"
      CONFIG_SSH=""
    else
      sleep 1 # Wait to clear possible message before dialog
      TYP="$(dialog --stdout --no-cancel --radiolist 'Select machine type:' 0 0 0 haut 'Haut/High' on bas 'Bas/Low' off)"
      echo "$TYP" > "$VAR/dsas_typ"
      chmod 644 "$VAR/dsas_typ"
      echo "Machine configured as type: ${GREEN}$TYP${NORMAL}"
      config_interco
      # The machine "haut" is configured from the web admin of "bas"
      [ "$TYP" = "bas" ] && config_network
      CONFIG_SSH="true"
      config_ssl
    fi
    setup_interco
    [ -z "$ISDOCKER" ] && /usr/bin/sethostname "$TYP"
    echo "# Hardcoded address of other DSAS machine" >> /etc/hosts
    [ "$TYP" = "bas" ] && echo "$INTERCO_HAUT haut" >> /etc/hosts
    [ "$TYP" = "haut" ] && echo "$INTERCO_BAS bas" >> /etc/hosts
    /bin/chmod a+r /etc/hosts
    start_network
    start_sshd
    start_syslog
    if [ "$TYP" = "bas" ]; then
      [ -n "$CONFIG_SSH" ] && config_sshd
      start_web_admin
      start_repo
      start_ntp
      start_radius
      start_antivirus
      start_snmp
      # Put root crontab file in place so it only runs on the machine bas
      /bin/cp $VAR/crontab.dsas /var/spool/cron/crontabs/root
      chown root.root /var/spool/cron/crontabs/root
      chmod 600 /var/spool/cron/crontabs/root
      start_cron
    fi

    start_chroot
    save_config
    ;;

  stop)
    if [ -f "$VAR/dsas_typ" ]; then
      TYP="$(cat "$VAR/dsas_typ")"
    else
      TYP="haut"
    fi
    stop_chroot
    if [ "$TYP" = "bas" ]; then
      stop_cron
      stop_snmp
      stop_antivirus
      stop_radius
      stop_ntp
      stop_repo
      stop_web_admin
    fi
    stop_syslog
    stop_sshd
    stop_network
    ;;

  restart)
    $0 stop
    sleep 1
    $0 start
    ;;

  reconfig)
    TYP="$(dialog --stdout --no-cancel --radiolist 'Select machine type:' 0 0 0 haut 'Haut/High' on bas 'Bas/Low' off)"
    echo "$TYP" > "$VAR/dsas_typ"
    chown 640 "$VAR/dsas_typ"
    echo "Machine configured as type: ${GREEN}$TYP${NORMAL}"
    config_interco
    setup_interco
    [ "$TYP" = "bas" ] && config_network
    config_sshd
    start_chroot --force
    $0 restart
    ;;

  apply)
    if [ -f "$VAR/dsas_typ" ]; then
      TYP="$(cat "$VAR/dsas_typ")"
    else
      TYP="haut"
    fi
    setup_interco
    # Only restart network if changed to avoid interupting transfers
    OLD=$(xmllint --xpath "dsas/config/network" "$VAR/dsas_conf.xml.active")
    NEW=$(xmllint --xpath "dsas/config/network" "$VAR/dsas_conf.xml")
    if [ "$OLD" != "$NEW" ]; then
      NO_INTERCO="true"
      stop_network
      start_network
    fi

    # Always restart openssh because the users rights might change
    SSHD_SIGHUP="true"
    start_sshd

    # The other services can be restarted without risk
    stop_syslog
    start_syslog
    if [ "$TYP" = "bas" ]; then
      stop_snmp
      start_snmp
      stop_antivirus
      start_antivirus
      stop_radius
      start_radius
      stop_ntp
      start_ntp
      stop_repo
      start_repo
    fi

    stop_chroot
    start_chroot
    save_config
    ;;

  *)
    exit 1
    ;;
esac

